{
    "status": true, 
    "model": {
        "tagAncestry": [], 
        "solved_count": 24095, 
        "can_solve": true, 
        "dynamic": true, 
        "epoch_starttime": null, 
        "difficulty_name": "Medium", 
        "compile_and_test": true, 
        "submit_disabled": false, 
        "company_id": null, 
        "languages": [
            "cpp", 
            "cpp14", 
            "java", 
            "java8", 
            "python"
        ], 
        "leaderboard_out_of_sync_message": null, 
        "primary_contest": null, 
        "factor": 20, 
        "default_language": null, 
        "leaderboard_out_of_sync": null, 
        "contest_slug": "master", 
        "name": "Tree: Huffman Decoding ", 
        "level": 31, 
        "success_ratio": 0.9727100238181745, 
        "total_count": 24771, 
        "moderator_or_support": false, 
        "codechecker_handle": null, 
        "java_template_tail": "", 
        "migrated_resource": null, 
        "custom_tabs": null, 
        "cpp14_template_head": "", 
        "is_skip_band_challenge": false, 
        "public_test_cases": true, 
        "available_translations": [], 
        "cpp_template": "/* \nThe structure of the node is\n\ntypedef struct node\n{\n    int freq;\n    char data;\n    node * left;\n    node * right;\n    \n}node;\n\n*/\n\n\nvoid decode_huff(node * root,string s)\n{\n    \n}", 
        "is_preview_contest": false, 
        "cpp_template_tail": "", 
        "hacker": {
            "username": "HackerRank", 
            "is_admin": true, 
            "id": 15055, 
            "avatar": "https://hrcdn.net/s3_pub/hr-avatars/4c95f96b-1ff9-46ed-98f8-cb3cb4ed8834/150x150.png"
        }, 
        "can_be_viewed": true, 
        "submitted_hackers_count": 24771, 
        "public_solutions": true, 
        "deleted": false, 
        "real_dynamic": false, 
        "difficulty_score": "0.0", 
        "difficulty": 0.7, 
        "active": true, 
        "slug": "tree-huffman-decoding", 
        "show_skeliton": false, 
        "player_count": 2, 
        "is_editorial_available": true, 
        "epoch_endtime": null, 
        "cpp_template_head": "", 
        "author_avatar": "https://hrcdn.net/s3_pub/hr-avatars/8d3fabd9-2280-4e75-8cca-9ea9d80415b1/150x150.png", 
        "judgebot_language": null, 
        "requirements_description": null, 
        "java_template": "/*  \n\tclass Node\n\t\tpublic  int frequency; // the frequency of this tree\n    \tpublic  char data;\n    \tpublic  Node left, right;\n    \n*/ \n\nvoid decode(String S ,Node root)\n    {\n        \n\n       \n    }", 
        "python_template": "\"\"\"class Node:\n    def __init__(self, freq,data):\n        self.freq= freq\n        self.data=data\n        self.left = None\n        self.right = None\n\"\"\"        \n\n# Enter your code here. Read input from STDIN. Print output to STDOUT\ndef decodeHuff(root , s):\n\t#Enter Your Code Here", 
        "color": null, 
        "has_all_test_cases_public": false, 
        "time_left": null, 
        "cpp14_template": "/* \nThe structure of the node is\n\ntypedef struct node\n{\n    int freq;\n    char data;\n    node * left;\n    node * right;\n    \n}node;\n\n*/\n\n\nvoid decode_huff(node * root,string s)\n{\n    \n}", 
        "kind": "code", 
        "is_custom": false, 
        "java8_template": "/*  \n\tclass Node\n\t\tpublic  int frequency; // the frequency of this tree\n    \tpublic  char data;\n    \tpublic  Node left, right;\n    \n*/ \n\nvoid decode(String S ,Node root)\n    {\n        \n\n       \n    }", 
        "solved_score": 0.5, 
        "expert_solution_status": false, 
        "custom": false, 
        "preview": "Given a Huffman tree and an encoded binary string, you have to print the original string.", 
        "cpp14_template_tail": "", 
        "company": null, 
        "is_text": false, 
        "java_template_head": "", 
        "require_unlock": true, 
        "has_started": true, 
        "judgebot": null, 
        "custom_checker_language": null, 
        "custom_case": true, 
        "topics": [], 
        "updated_at": "2017-06-01T12:50:45.000Z", 
        "author_name": "vatsalchanana", 
        "onboarding": null, 
        "id": 8795, 
        "has_ended": false, 
        "is_solution_unlocked": false, 
        "checker_program": null, 
        "status": null, 
        "category": "ai", 
        "track": {
            "name": "Trees", 
            "taxonomy": 1, 
            "track_slug": "data-structures", 
            "track_id": 17, 
            "track_name": "Data Structures", 
            "id": 96, 
            "rewards_system_enabled": null, 
            "slug": "trees"
        }, 
        "body_html": "<div class='challenge_problem_statement'><div class='msB challenge_problem_statement_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. A Huffman tree is made for the input string and characters are decoded based on their position in the tree. We add a '0' to the codeword when we move left in the binary tree and a '1' when we move right in the binary tree. We assign codes to the leaf nodes which represent the input characters.</p>\n\n<p>For example :</p>\n\n<pre><code>        {\u03d5,5}\n     0 /     \\ 1\n    {\u03d5,2}   {A,3}\n   0/   \\1\n{B,1}  {C,1}  \n</code></pre>\n\n<p>Input characters are only present on the leaves. Internal nodes have a character value of \u03d5.\nCodewords:   </p>\n\n<pre><code>A - 1\nB - 00\nC - 01\n</code></pre>\n\n<p>No codeword appears as a prefix of any other codeword. Huffman encoding is a prefix free encoding technique.</p>\n\n<p>Encoded String \"1001011\" represents the string \"ABACA\"</p>\n\n<p>You have to decode an encoded string using the Huffman tree.</p>\n\n<p>You are given pointer to the root of the Huffman tree and a binary coded string. You need to print the actual string.</p></div></div></div><div class='challenge_input_format'><div class='msB challenge_input_format_title'><p><strong>Input Format</strong></p></div><div class='msB challenge_input_format_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>You are given a function,</p>\n\n<pre><code>void decode_huff(node * root, string s)\n{\n\n}\n</code></pre>\n\n<p>The structure for node is defined as : </p>\n\n<pre><code>struct node\n{\n    int freq;\n    char data;\n    node * left;\n    node * right;\n\n}node;    \n</code></pre>\n\n<p><strong>Note:</strong> <br>\nInternal nodes have data='\\0'(\u03d5 )</p></div></div></div><div class='challenge_output_format'><div class='msB challenge_output_format_title'><p><strong>Output Format</strong></p></div><div class='msB challenge_output_format_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>Output the decoded string on a single line.</p></div></div></div><div class='challenge_sample_input'><div class='msB challenge_sample_input_title'><p><strong>Sample Input</strong></p></div><div class='msB challenge_sample_input_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><pre><code>         {\u03d5,5}\n      0 /     \\ 1\n     {\u03d5,2}   {A,3}\n    0/   \\1\n{B,1}  {C,1}  \n\nS=\"1001011\"\n</code></pre></div></div></div><div class='challenge_sample_output'><div class='msB challenge_sample_output_title'><p><strong>Sample Output</strong></p></div><div class='msB challenge_sample_output_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><pre><code>ABACA\n</code></pre></div></div></div><div class='challenge_explanation'><div class='msB challenge_explanation_title'><p><strong>Explanation</strong></p></div><div class='msB challenge_explanation_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><pre><code>S=\"1001011\"\nProcessing the string from left to right.\nS[0]='1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[1]='0' : we move to the left child. \nS[2]='0' : we move to the left child. We encounter a leaf node with value 'B'. We add 'B' to the decoded string.\nWe move back to the root.\n\nS[3] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nS[4]='0' : we move to the left child. \nS[5]='1' : we move to the right child. We encounter a leaf node with value C'. We add 'C' to the decoded string.\nWe move back to the root.\n\n S[6] = '1' : we move to the right child of the root. We encounter a leaf node with value 'A'. We add 'A' to the decoded string.\nWe move back to the root.\n\nDecoded String = \"ABACA\"\n</code></pre></div></div></div>", 
        "max_score": 20, 
        "user_score": 0, 
        "created_at": "2015-06-17T04:27:54.000Z", 
        "countdown_time": 0
    }
}