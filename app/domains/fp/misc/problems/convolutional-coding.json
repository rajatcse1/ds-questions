{
    "status": true, 
    "model": {
        "onboarding": null, 
        "tagAncestry": [], 
        "solved_count": 28, 
        "leaderboard_out_of_sync_message": null, 
        "public_test_cases": true, 
        "checker_program": "{-# LANGUAGE DeriveGeneric #-}\n\nmodule Main where\n\nimport           Control.Applicative\nimport           Control.Arrow\nimport           Control.Monad\nimport           Data.Aeson\nimport qualified Data.ByteString.Lazy as B\nimport           Data.Char\nimport           Data.List\nimport           GHC.Generics\nimport           Text.Printf -- printf \"%0.6f\" (1.0)\n\ndata Request = Reqest {\n    expected_outputs :: [String]\n  } deriving (Show, Generic)\n\ninstance FromJSON Request\n\ngrade :: String -> String -> Double\ngrade actual expected = errs / len\n  where errs = sum (zipWith errorMap actual expected)\n        len = fromIntegral (length expected)\n        errorMap a b = if a == b then 1 else 0\n\nvalidate :: String -> String -> String -> Double\nvalidate input1 output1 expOutput1 =\n  case (output, expOutput) of\n    ([o], [e]) -> grade o e\n    _          -> 0\n  where\n    input     = lines. trimSpaces $ input1\n    output    = lines. trimSpaces $ output1\n    expOutput = lines. trimSpaces $ expOutput1\n\ntrimSpaces :: String -> String\ntrimSpaces = reverse. dropWhile isSpace. reverse\n\nfromRight :: Either a b -> b\nfromRight (Right x) = x\n\nmean :: [Double] -> Double\nmean xs = sum xs / genericLength xs\n\nmain :: IO ()\nmain = do\n  subDir <- filter isPrint <$>getContents\n  jsonContent <- B.readFile (subDir ++ \"request.json\")\n  let\n    expOutputs :: [String]\n    expOutputs = expected_outputs. fromRight. eitherDecode $ jsonContent\n  scores <- forM (zip [(0::Int)..] expOutputs) $ \\(idx, expOutput) -> do\n    --input  <- readFile (subDir ++ printf \"input%05d.in\"   idx)\n    output <- readFile (subDir ++ printf \"output%05d.out\" idx)\n    return (validate \"\" output expOutput)\n  print (mean scores)\n  putStrLn (unwords. map show $ scores)\n\n", 
        "topics": [], 
        "time_left": null, 
        "updated_at": "2016-09-01T16:43:09.000Z", 
        "author_name": "jspha", 
        "has_started": true, 
        "epoch_starttime": null, 
        "has_all_test_cases_public": false, 
        "difficulty_name": "Expert", 
        "require_unlock": true, 
        "body_html": "<div class='challenge_problem_statement'><div class='msB challenge_problem_statement_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><h1>Convolutional Codes</h1>\n\n<p><em>\u201cThe fundamental problem of communication is that of reproducing at one point either exactly or approximately a message selected at another point.\u201d</em></p>\n\n<p>\u2014 Claude Shannon</p>\n\n<p>Imagine designing a protocol to communicate with a robot 12 billion miles away from you. No matter what the size of your communication array, you must accept that the message will likely arrive garbled, confused, noisy, and weak. You could try to send the same message over-and-over again, hoping that at least one of your messages will make it through unscathed; but, how many times is enough? How will this affect the cost of sending messages, or the responsiveness to your messages?</p>\n\n<p>Back on earth, imagine communicating with a computer with only a tiny antenna which moves erratically throughout cities across the globe. No matter how you design your broadcast antennas, your messages will\narrive garbled, confused, noisy, and weak... but cell signals still have to work somehow (most of the time, anyway).</p>\n\n<p>These are both problems of <em>robust coding</em>. This challenge is to implement encoding and decoding algorithms for a particularly nice kind of robust coding: a <em>convolutional code</em>. These codes were a major component of the communications algorithm for Voyagers 1 and 2, Cassini, Mars Explorer, and Pathfinder.</p>\n\n<hr>\n\n<p>Convolutional codes are a form of stream coding invented by Peter Elias in 1955. Convolutional codes consist of an encoder and a decoder and are advantageous because the encoder is incredibly simple and the\ndecoder is parallelizable.</p>\n\n<p>Convolutional codes are classified by two numbers, (<em>N</em>, <em>K</em>). <em>N</em> is the <em>output bit count</em> and <em>K</em> is the <em>constraint length</em>. More informally, N counts the number of output transmit bits encoded for each input source bit, meaning that a convolutional code transmits source data at a rate of 1/N source bits per transmitted bits; K describes the amount of internal memory the encoder has, dramatically impacting the complexity of decoding.</p>\n\n<p>For example, Voyager 1 and 2 used a (2, 7) convolutional code, while Mars Exploration Rover and Pathfinder used a (6, 15) code.  </p>\n\n<p>To fully classify an (<em>N</em>, <em>K</em>) convolutional code, we also need <em>N</em> bit vectors <em>g0</em> through <em>g(N-1)</em>, each of length <em>K</em>. These are the <em>coding polynomials</em>.</p>\n\n<p>Briefly, if you're familiar with DSP, a convolutional code encoder works by producing one output stream for each coding polynomial by convolving the polynomial with the input stream.</p>\n\n<p>Briefly, if you're familiar with inference on Markov models, a convolutional code decoder works by using the Viterbi algorithm to infer the most likely latent state of the encoder given an observed output stream and then reads the input stream off of it.</p>\n\n<hr>\n\n<p>Ultimately, the goal of this challenge is to decode a message sent from Voyager and recode it for transmission to Pathfinder. More specifically, you'll be provided with the coding polynomials for an incoming message that you must decode, and then a new set of coding polynomials to use to re-encode the message to deliver elsewhere.</p>\n\n<p>It may be the case that the messages you receive are corrupted with random bit-flipping noise---but the convolutional code decoder will account for this, ensuring perfect transmission (with a high degree of probability).</p>\n\n<p>What follows describes how to build a convolutional code encoder and decoder and then the format and limits of the challenge.</p>\n\n<h2>Convolutional Encoding</h2>\n\n<p>Let's first consider a very simple (2, 1) convolutional code with coding polynomials.</p>\n\n<pre><code>g0 = [1]\ng1 = [1]\n</code></pre>\n\n<p>This will turn out to be the \"repeat 2\" code. Encoding works like this:</p>\n\n<pre><code>(+) ---&gt; t0\n ^\n |\n m0 &lt;--- s\n |\n v\n(+) ---&gt; t1\n</code></pre>\n\n<p>Imagine the above shift register circuit as mapping the flow of bits through the encoder. Bits flow in through <code>s</code>  one-by-one, and are stored in a memory cell  <code>m0</code>. Then, we flow further to emit the first two transmitted bits <code>t0</code> and <code>t1</code>, which are both simply copies of the data stored in <code>m0</code>. Thus, if you put a source bit <code>0</code> in at <code>s</code> then both <code>t0</code> and <code>t1</code> emit <code>0</code> and visa versa.</p>\n\n<p>The structure of this shift register is encoded in the coding polynomials. In particular, <code>g0[0] = 1</code> indicates that <code>t0</code> is a sum including data from memory cell <code>m0</code> and likewise for <code>g1[0] = 1</code> and <code>t1</code>.</p>\n\n<p>All memory cells are initialized with 0 and all computation is performed in the binary ring Z2, e.g. addition is XOR, multiplication is AND.</p>\n\n<p>A more complex example introduces the idea of delays. Consider the following polynomials</p>\n\n<pre><code>g0 = [1,0]\ng1 = [0,1]\n</code></pre>\n\n<p>which correspond to the following shift register diagram</p>\n\n<pre><code> (+) ---&gt; (+) ---&gt; t0\n           ^\n           |\n  m1  &lt;&lt;&lt;  m0 &lt;--- s\n  |         \n  v         \n (+) ---&gt; (+) ---&gt; t1\n</code></pre>\n\n<p>or, drawn more simply,</p>\n\n<pre><code>          (+) ---&gt; t0\n           ^\n           |\n  m1  &lt;&lt;&lt;  m0 &lt;--- s\n  |         \n  v         \n (+) ------------&gt; t1\n</code></pre>\n\n<p>In this diagram, the <code>&lt;&lt;&lt;</code> indicates a \"delay\". When a signal bit is fed in through <code>s</code> it updates the value of <code>m0</code> and the old value of <code>m0</code> \"flows\" on to update the value of <code>m1</code>. Then, the values of <code>m0</code> and <code>m1</code> are queried to produce the output bits <code>t0</code> and <code>t1</code>.</p>\n\n<p>This code produces an output message which goes \"two steps forward one step back\". As an example, the input signal <code>[1,1,0,1,1]</code> produces the output signal <code>[[1,0],[1,1],[0,1],[1,0],[1,1]]</code> where the first value of each pair is the same as the input and the second value is the value of the memory register <code>m0</code> in the previous state.</p>\n\n<p>Finally, we can see how the coding polynomials indicate the structure of the encoder more clearly now that there are multiple memory cells. In general, an (<em>N</em>, <em>K</em>) convolutional code has <em>N</em> output lines and <em>K</em> memory cells.</p>\n\n<p>As a final example, consider the (2, 7) convolutional code used in the Voyager messages. It has coding polynomials <code>g0 = [1,1,1,1,0,0,1]</code> and <code>g1 = [1,0,1,1,0,1,1]</code> which results in the following</p>\n\n<pre><code>(+)------------(+)--(+)--(+)--(+) ---&gt; t0\n ^              ^    ^    ^    ^\n |              |    |    |    |\n m6 &lt; m5 &lt; m4 &lt; m3 &lt; m2 &lt; m1 &lt; m0 &lt;--- s\n |    |         |    |         |\n v    v         v    v         v\n(+)--(+)-------(+)--(+)-------(+) ---&gt; t1\n</code></pre>\n\n<h3>Additional Notes on Convolutional Encoding</h3>\n\n<p>The examples above provide the general idea, but these notes are important for understanding conventions and use of encoders.</p>\n\n<ul>\n<li>Convolutional encoding follows a shift register model.</li>\n<li>You can generate each \"frame\" of an encoding using a single matrix\nmultiply.</li>\n<li>Typically we write the output bitstream as the concatenation of each\noutput frame, so an output <code>[[1,0],[1,1],[0,1],[1,0],[1,1]]</code>\nbecomes the bitstream <code>1011011011</code>.</li>\n<li>We assume all of the registers are zeroed to start.</li>\n<li>After the last source bit is sent, we send <em>K</em> more zeros to pad the message. This clears all of the remaining information from memory and sends it along the channel.</li>\n</ul>\n\n<h3>Examples</h3>\n\n<ul>\n<li>For <code>g0 = [1]</code> encoding is the identity.</li>\n<li>For <code>g0 = [1]</code>, <code>g1 = [1]</code>, <code>g2 = [1]</code> encoding is \"repeat thrice\".</li>\n<li><p>For the (2,7) Voyager code above, sending the ASCII stream \"hi\",\n<code>0110100001101001</code> results in the output.</p>\n\n<p><code>0011010111011001111010011101101001100000011100</code></p>\n\n<p>a stream of <code>(16*N + K*N)</code> bits including the padding zeros.</p></li>\n</ul>\n\n<h2>Convolutional Decoding</h2>\n\n<p>The key to decoding a convolutional code efficiently under potential errors (bit-flips) introduced by the communication channel is to think of the shift register encoding circuit as a <em>finite state machine</em> (FSM).</p>\n\n<p>In particular, an (<em>N</em>, <em>K</em>) code has <code>2^K</code> states and emits <em>N</em> symbols (bits) on transition.</p>\n\n<p>As an observer of only the output bits the decoder must somehow model its <em>best guess</em> as to the internal state of the encoder. This is known as the <em>maximum likelihood estimate</em> of the encoder state. Once we have the MLE of the state trajectory of the encoder over the entire transmitted message we can read off <code>m0</code> (and chop off the tail padding) to recover our best guess at the input message.</p>\n\n<p>Since an (<em>N</em>, <em>K</em>) encoder sends <em>N</em> bits for every one input bit it's likely that even if some number of those transmitted bits are flipped it won't prevent the MLE from still being accurate to the source message. This is where the <em>robustness</em> of the convolutional code comes from.</p>\n\n<p>The next question to tackle is how to create an MLE of the internal state of a FSM given only its emitted output. For this, we'll consider a small but non-trivial example (2,2) code with <code>g0 = [0,1]</code> and <code>g1 = [1,1]</code>. Since <em>K</em>=2 there are 4 internal states of the encoder: <code>s=00</code>, <code>01</code>, <code>10</code>, and <code>11</code>. The encoder begins in state <code>00</code> and we can model the system's responses to an input bit of <code>0</code> or <code>1</code>.</p>\n\n<p>If the first input bit is <code>0</code> then the new state is <code>00</code> (still) and the encoder emits the bits <code>s*g0 = 0</code> and <code>s*g1 = 0</code> where <code>(*)</code> is the vector inner or \"dot\" product. If the first input were <code>1</code> instead then the new state is <code>10</code> and the encoder emits <code>s*g0 = 0</code> and <code>s*g1 = 1</code>. What's important to note is that there are only two possible emissions from this first bit (<code>00</code> and <code>01</code>), but when we receive the first two bits there is a chance one has been flipped so we may actually observe any of the four possibilities <code>00</code>, <code>01</code>, <code>10</code>, or <code>11</code>.</p>\n\n<p>So, to be clear, imagine that the first source bit was <code>1</code> and thus the encoder emitted the two bits <code>01</code>. Now, let's imagine that we actually observe the bits <code>11</code>. If we take the <em>Hamming Distance</em>, the number of un-matching bits, between the observed pair of bits and each of the two possiblilities we'll see that the bit emission <code>00</code> is at Hamming Distance 2 from what we observed while the bit emission <code>01</code> is at Hamming Distance 1. Thus, from this data alone, our MLE of the source signal is <code>1</code>, which happens to be accurate. This demonstrates the decoder recovering from a single error.</p>\n\n<pre><code>Frame 1 Summary      Verdict\n----------------     -------\nSource      = 1\nTransmitted = 01\nReceived    = 11\nMLE         = 1      MATCH!\n</code></pre>\n\n<p>The other thing that our MLE suggests is that the new state of the encoder after the first signal bit is <code>10</code>. We could use this as the assumed internal state for decoding the next bit and repeat the process. </p>\n\n<p>While iterating this process this captures the spirit of an MLE, it is unfortunately insufficient. In particular, if we had been <em>wrong</em> about the first bit then we would continue on a false assumption about the internal state. As a result, we'll almost certainly be wrong about every subsequent bit.</p>\n\n<p>Instead, what we'll want to do is consider <em>all possible paths</em> through the space of internal states and keep only the most likely (smallest net Hamming Distance) path. This will be the MLE.</p>\n\n<h3>Constructing state space on a Trellis</h3>\n\n<p>To construct the actual decoder algorithm we need to take the intuition gained from examining the encoder as an FSM and extend it to take account of transitions over time better. For this we will introduce a kind of graph called a Trellis.</p>\n\n<p>A Trellis is a visual representation of the information and state of the convolutional encoder displayed against the actual received message. It's laid out in a grid of <code>2^K</code> rows each with <code>L/N+1</code> columns where <code>L</code> is the length of the received message. Each column will be called an <em>epoch</em> and each row represents a particular selection of encoder state. The first epoch is the time before the encoder has received any inputs (and thus is in the all zero state), then between each epoch an input bit is received an <code>N</code> output bits are emitted leaving the encoder in a new state.</p>\n\n<p>For the (2,2) code from the previous section, this looks like the following for <code>L = 14</code></p>\n\n<pre><code>      State\nEpoch -----  0   1   2   3   4   5   6   7\n\n         11          ()  ()  ()  ()\n         01          ()  ()  ()  ()  ()\n         10      ()  ()  ()  ()  ()  \n         00  ()  ()  ()  ()  ()  ()  ()  ()\n             ------  --------------  ------\n             filling \"steady state\"  flushing\n</code></pre>\n\n<p>Here the <code>()</code> indicates a <em>possible state</em> over time. In the region marked \"filling\" we note that (assuming, as usual, that the encoder begins in the all zero state) after receiving the first signal bit it is not posible for the encoder to reach states like <code>01</code> or <code>11</code>. On the other side there's the \"flushing\" zone which represents the trailing zero-padding in the signal used to flush the memory back to the all zero state.</p>\n\n<p>Since this Trellis has 8 epochs it represents a message of <code>N*(8-1)</code> transmitted bits or <code>7</code> signal bits. Additionally, since <code>K=2</code> the last two signal bits must have been <code>0</code>s to flush the encoder state so the true signal must have been 5 bits long.</p>\n\n<p>Now that we have the Trellis grid, we should consider transitions. A transition between epoch <code>t</code> and epoch <code>t+1</code> occurs when the <code>t+1</code>th signal bit is consumed by the encoder and <code>N</code> outbit bits released leaving the encoder in a (potentially) new internal state. For instance, consider the transition from epoch <code>0</code> to epoch <code>1</code>. We begin in coordinate (00,0) and if the <code>1</code>st signal bit is a <code>0</code> then we'll transition to coordinate (00, 1) and emit the output bits <code>00</code>. If it were a <code>1</code> then we'll transition to coordinate (10, 1) and emit the output bits <code>01</code>.</p>\n\n<h3>Estimating the MLE with Viterbi's min-sum algorithm</h3>\n\n<p>Now that we have a Trellis for our encoder we can use it to compute the MLE with ease. If we consider a path from epoch 0 to epoch <code>L/N</code> we can easily compute the message which <em>ought</em> to have been transmitted and furthermore we can compute the net Hamming ditance between that supposed message and the one we actually received. We'll determine the MLE by finding the state-space path with output message of the smallest Hamming distance from the message we received.</p>\n\n<p>We know that we must arrive at the final epoch of the Trellis in state <code>00</code>, so we  ask \"What is the minimum <em>distortion</em> path to arrive at (00,<em>L/N</em>) given the transmission we received?\". Viterbi's recursive min-sum algorithm is an elegant way to solve this.</p>\n\n<p>To run this example we'll need a received input. Let's imagine we receive the following (possibly corrupted) 14 bits</p>\n\n<pre><code>01101110011100\n</code></pre>\n\n<p>What was the code that generated this transmission?</p>\n\n<p>We'll work from the tail end producing the value <code>MS(00,7)</code> which is a pair of values <code>(path, distance)</code> where <code>path</code> is the minimum-length path through state space taken by encoder and <code>distance</code> is the net Hamming distance between what ought to have been transmitted and what we actually received. Since we could only have transitioned from either (01,6) or (00,6) we consider recursively those two emissions, <code>MS(01,6)</code> and <code>MS(00,6)</code>. Since both transitions <code>(01,6) -&gt; (00,7)</code> and <code>(00,6) -&gt; (00,7)</code> result in the emission of the output bits <code>00</code> and those are indeed what we observed then this transition does not increase the net Hamming distance of the path. Therefore, the minimal distortion path arriving at <code>MS(00,7)</code> is the shorter (the <em>min</em> part) of the two paths <code>MS(01,6)</code> and <code>MS(00,6)</code> appending (the <em>sum</em> part) the transition to state <code>00</code> and the increased distortion (in this case 0).</p>\n\n<p>This algorithm continues recursively until we arrive at coordinate <code>(00,0)</code> where <code>MS(00,0) = ([],0)</code> by definition.</p>\n\n<p>When this algorithm completes we simply take the <code>path</code> component from <code>MS(00,7)</code> and read off the <code>0</code>th memory cell from the internal state of the encoder: this is the most likely input signal estimate!</p>\n\n<p>If you complete the Trellis from the previous example you will find that the source message was <code>11001</code>.</p>\n\n<h3>Notes</h3>\n\n<ul>\n<li>If you're paying close attention you may have noticed that it's not necessary to actually transmit output from the final, <code>K</code>th flushing bit since it always drives the system to the all-zero state which means the final bits are constant: <code>00</code>. A real system would avoid sending these.</li>\n</ul>\n\n<h2>Resources</h2>\n\n<ul>\n<li><a href=\"http://www3.cs.stonybrook.edu/~jgao/CSE590-fall09/viterbi.pdf\">Notes on Convolutional Coding</a></li>\n<li><a href=\"http://www.inference.phy.cam.ac.uk/mackay/itprnn/ps/574.581.pdf\">Chapter 48</a> of <a href=\"http://www.inference.phy.cam.ac.uk/mackay/itprnn/ps/\">David McKay's <em>Information Theory, Inference, and Learning Algorithms</em></a></li>\n</ul></div></div></div><div class='challenge_input_format'><div class='msB challenge_input_format_title'><p><strong>Input Format</strong></p></div><div class='msB challenge_input_format_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>An input specification contains 3 pieces:</p>\n\n<ol>\n<li>The configuration of the receiving decoder</li>\n<li>The configuration of the transmitting encoder</li>\n<li>An incoming encoded bitstream</li>\n</ol>\n\n<p>The two configurations are both represented in the same way. First, there is a line determining the <em>N</em> and <em>K</em> parameters of the code, and then there are <em>N</em> lines each with a length-<em>K</em> bitstring which indicate the <em>N</em> coding polynomials.</p>\n\n<p>Thus, a problem which asks you to receive a Voyager-encoded message and then transmit it as a thrice-duped message looks like</p>\n\n<pre><code>2 7\n1111001\n1011011\n3 1\n1\n1\n1\n</code></pre>\n\n<p>The incoming message is simply an arbitrary length encoded bitstream. For reading convenience there may be whitespace included and this should be ignored.</p></div></div></div><div class='challenge_output_format'><div class='msB challenge_output_format_title'><p><strong>Output Format</strong></p></div><div class='msB challenge_output_format_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>Many of the test cases include the addition of random transmission errors. It is possible that these errors cannot be corrected by the decoder\u2014too much information has been lost. <br>\nGrading for this problem is thus not all-or-nothing but, instead, answers are penalized according to the <a href=\"http://en.wikipedia.org/wiki/Hamming_distance\">hamming distance</a> between the error-free correct result and the actual output. For this reason, even a perfectly performing submission may not receive a perfect score. <br>\nTest cases 0-9 are extremely low-error transmissions, however. A functioning decoder should successfully decode them perfectly.</p></div></div></div><div class='challenge_sample_input'><div class='msB challenge_sample_input_title'><p><strong>Sample Input</strong></p></div><div class='msB challenge_sample_input_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><pre><code>2 7\n1111001\n1011011\n3 1\n1\n1\n1\n001110000100000010000010110110011110100111011010010101101111011111110011\n010000011111010111011010010101101111011111110011010000011111010100001101\n001100011011001011111110011111101011010110000001111101101011000101000010\n111011110101100001000001111101010011101110111000010100100010110110110010\n111111101001000110010001111101111100101111010110000111101000000111110101\n000011101000111001110011110000111100001111000011001011110110000000110100\n011101110111000101000001100001111111001101000001111101010011010101001010\n110000010111100111110001111101101011001011111110100111001101111100011010\n010101011001000110010010010001010100100101110000011111110110101001010101\n100111001101111111110101010010010100100000000100001000100010111000001110\n101101011000000111110101001101010100100101111101001100100011010101001010\n111110101000011010110001010000100011010101001010110000010100001011011010\n010101011001111101100011010111001101110001000111111100111001101111101010\n110000\n</code></pre></div></div></div><div class='challenge_sample_output'><div class='msB challenge_sample_output_title'><p><strong>Sample Output</strong></p></div><div class='msB challenge_sample_output_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>(The following is displayed with apparent whitespace wrapping. This should not be included in the actual output.)</p>\n\n<pre><code>000111000111000111000000000111111000111000000000000111111000111000000111000111111111000000111111000000111000000000000000000111111000111000000111000111111111000000111111000000111000000000000000000111111000000111000000000111111111000111000111000111111000000111000111000000111000000000000000000111111111000111000000000111111000111111111111000000111000000000000000000111111000000000111111000111111000111111000000000111111111000111000111000111111000111111000111000111111111000000111111000111111111111000000111000000111000000000000000000111111000000111000111000111111000000111111000000111111000000111111000000111111000111111111111000111111111000000111000000111111111000111000000000111111111000000111111000000111000000000000000000111111000000000000111000111111111000111000000000000111000000000000000000111111111000111000111000111111000111111111000000111111000111000000111000111111000111111000111000111111000000000000111000111111000000111111111000111111000111000000111000111111000111111111000000111111000000000000111000111111000000000111000000111111000111111000000000111111000000111000111000000111000000000000000000111111000000000000111000111111000000111000000000111111000000000000111000111111111000000000000000111111111000111000000000111111000000000000111000111111111000111000000000111111000111000000111000111111000111111111111000111111000111111111000000111111111000000111111000000111000111111111000000\n</code></pre></div></div></div><div class='challenge_explanation'><div class='msB challenge_explanation_title'><p><strong>Explanation</strong></p></div><div class='msB challenge_explanation_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>The sample input specifies first the Voyager (2,7) code with coding polynomials <code>g0 = [1,1,1,1,0,0,1]</code> and <code>g1 = [1,0,1,1,0,1,1]</code> which corresponds to the following shift register diagram</p>\n\n<pre><code>(+)------------(+)--(+)--(+)--(+) ---&gt; t0\n ^              ^    ^    ^    ^\n |              |    |    |    |\n m6 &lt; m5 &lt; m4 &lt; m3 &lt; m2 &lt; m1 &lt; m0 &lt;--- s\n |    |         |    |         |\n v    v         v    v         v\n(+)--(+)-------(+)--(+)-------(+) ---&gt; t1\n</code></pre>\n\n<p>It then specifies the (3,1) thrice-repeating code with coding polynomials <code>g0 = [1]</code>, <code>g1 = [1]</code>, and <code>g2 = [1]</code> which corresponds to the following shift register diagram</p>\n\n<pre><code>m0 &lt;--- s\n|\n*-----&gt; t1\n|\n*-----&gt; t2\n|\n*-----&gt; t3\n</code></pre>\n\n<p>Finally, it lists a 942 bit encoded message on 14 lines although the whitespace must be deleted before interpretation as a single bitstream.</p>\n\n<p>The output is that input decoded probabilistically according to the Voyager model and then re-encoded using the repeat-thrice code. It is printed as 1395 bits.  </p>\n\n<hr>\n\n<p><strong>Tested by</strong> <a href=\"https://www.hackerrank.com/pakso\">Stanislav Pak</a> <br>\n<br></p></div></div></div>", 
        "hacker": {
            "username": "HackerRank", 
            "is_admin": true, 
            "id": 15055, 
            "avatar": "https://hrcdn.net/s3_pub/hr-avatars/4c95f96b-1ff9-46ed-98f8-cb3cb4ed8834/150x150.png"
        }, 
        "id": 5507, 
        "leaderboard_out_of_sync": null, 
        "has_ended": false, 
        "languages": [
            "haskell", 
            "clojure", 
            "scala", 
            "erlang", 
            "sbcl", 
            "ocaml", 
            "fsharp", 
            "racket", 
            "elixir"
        ], 
        "is_custom": true, 
        "compile_and_test": true, 
        "default_language": null, 
        "migrated_resource": null, 
        "submit_disabled": null, 
        "expert_solution_status": false, 
        "can_solve": true, 
        "company_id": null, 
        "custom": true, 
        "can_be_viewed": true, 
        "track": {
            "name": "Ad Hoc", 
            "taxonomy": 3, 
            "track_slug": "fp", 
            "track_id": 5, 
            "track_name": "Functional Programming", 
            "id": 41, 
            "rewards_system_enabled": null, 
            "slug": "misc"
        }, 
        "primary_contest": {
            "migration_status": null, 
            "contest_broadcast": null, 
            "hacker_timelimit": null, 
            "notification": null, 
            "qualification_rule_value": null, 
            "leaderboard_backend": null, 
            "expose_stats": null, 
            "updated_at": "2016-05-06T21:57:08.000Z", 
            "custom_leaderboard_column_name": null, 
            "organization_type": null, 
            "ended": true, 
            "epoch_starttime": 1418970600, 
            "timezone": "PST", 
            "disable_forum": null, 
            "id": 1670, 
            "primary_track_id": 5, 
            "limited_participants": null, 
            "school_leaderboard_enabled": false, 
            "time_limited_contest": false, 
            "archived": true, 
            "rated": null, 
            "parent_contest_id": null, 
            "leaderboard_out_of_sync_message": null, 
            "leaderboard_type": "country", 
            "tagline": "A contest for functional programming enthusiasts", 
            "effective_epoch_endtime": 1419834600, 
            "show_participants_info": null, 
            "homepage_background_color": "", 
            "organization_name": null, 
            "track": {
                "name": "Functional Programming", 
                "id": 5, 
                "priority": 2, 
                "descriptions": "The art of programming with expressions and functions. Experience the challenge of programming without state. A good paradigm for those interested in Map-Reduce and parallel computing.", 
                "rewards_system_enabled": null, 
                "slug": "fp"
            }, 
            "primary_tag_id": null, 
            "hide_navigation": null, 
            "show_penalty": true, 
            "effective_time_left": -83522271.0020131, 
            "hidden": null, 
            "homepage": "", 
            "public": true, 
            "testers_contest": null, 
            "description": "The contest hosts 7 challenges ranging from algorithms to logics to compilers. \n<br><br>\n<strong>Problem Setters</strong> <a href=\"/jspha\">Joseph Abrahamson</a>, <a href=\"/Javran\">Javran (Fang) Cheng</a>, <a href=\"/Buda\">Ivan Buda Mandura</a>, <a href=\"/pakso\">Stanislav Pak</a>, <a href=\"/havingfun\">Rajesh Kumar</a>, <a href=\"/abhiranjan\">Abhiranjan</a>.\n<br><br>\n<strong>Validators</strong> <a href=\"/patsp\">Patrick Spettel</a>, <a href=\"/pakso\">Stanislav Pak</a>, <a href=\"/shaka_shadows\">Ray Williams Robinson Valiente</a>, <a href=\"/Buda\">Ivan Buda Mandura</a>, <a href=\"/stoundmire\">Bo You</a>, <a href=\"/wanbo\">Wanbo</a>, <a href=\"/abhiranjan\">Abhiranjan</a>.\n<br><br>\n<strong>Languages allowed</strong>: <i>Haskell, Racket, Clojure, OCaml, F#, Scala, Common Lisp and Erlang.</i>\n<br><br>\n<strong>Want to contribute problems?</strong> Mail to  <a href=\"mailto:hackers@hackerrank.com?subject=Lambda Calculi\">hackers@hackerrank.com</a> with the subject \"Lambda Calculi\".\n", 
            "hide_difficulty": null, 
            "started": true, 
            "time_left": -83522270.99695796, 
            "challenges_count": 7, 
            "qualification_rule_msg": null, 
            "leaderboard_out_of_sync": null, 
            "team_event": false, 
            "disable_fsi": null, 
            "hide_submissions": null, 
            "leaderboard_format": "", 
            "leaderboard_broadcast_message": null, 
            "has_tracks": null, 
            "college_public": null, 
            "endtime": "2014-12-29T06:30:00.000Z", 
            "qualification_rule_type": null, 
            "slug": "lambda-calculi-9", 
            "hide_leaderboard": null, 
            "kind": null, 
            "comment_live_sync": null, 
            "name": "Lambda Calculi - 9", 
            "is_multi_round": false, 
            "created_at": "2014-10-19T04:10:23.000Z", 
            "epoch_endtime": 1419834600, 
            "company_associated_contest": null, 
            "rating_category": null, 
            "has_codesprint_reg_page": null, 
            "starttime": "2014-12-19T06:30:00.000Z", 
            "is_rating_updated": true, 
            "leaderboard_freeze_time": null, 
            "migration_disabled": null, 
            "template_id": 254
        }, 
        "factor": 200, 
        "is_solution_unlocked": false, 
        "preview": "Convolutional codes are a mechanism for sending messages across an unreliable channel with minimal recipient confusion. Encoding is carried out using a shift register model and decoding is carried out using a probabilistic model with fast posterior maximization via the Viterbi algorithm.", 
        "is_editorial_available": true, 
        "status": null, 
        "category": "ai", 
        "public_solutions": true, 
        "color": null, 
        "deleted": false, 
        "dynamic": true, 
        "company": null, 
        "moderator_or_support": false, 
        "is_text": false, 
        "solved_score": 0.2, 
        "difficulty_score": "0.167", 
        "difficulty": 0.1, 
        "active": true, 
        "show_skeliton": null, 
        "max_score": 200, 
        "slug": "convolutional-coding", 
        "contest_slug": "master", 
        "user_score": 0, 
        "real_dynamic": false, 
        "kind": "code", 
        "player_count": 2, 
        "submitted_hackers_count": 31, 
        "name": "[Approximate Challenge] Convolutional Coding", 
        "is_preview_contest": false, 
        "level": 95, 
        "success_ratio": 0.9032258064516129, 
        "total_count": 31, 
        "created_at": "2014-12-09T19:18:00.000Z", 
        "epoch_endtime": null, 
        "judgebot": null, 
        "available_translations": [], 
        "codechecker_handle": null, 
        "countdown_time": 0, 
        "author_avatar": "https://secure.gravatar.com/avatar/2bc1bffafe7aa29ef900b98d1fd1e94e?d=https://d3rpyts3de3lx8.cloudfront.net/hackerrank/assets/gravatar.jpg&s=150", 
        "custom_tabs": null, 
        "judgebot_language": null, 
        "custom_case": true, 
        "requirements_description": null, 
        "is_skip_band_challenge": false, 
        "custom_checker_language": "haskell"
    }
}