{
    "status": true, 
    "model": {
        "onboarding": null, 
        "tagAncestry": [], 
        "solved_count": 199, 
        "leaderboard_out_of_sync_message": null, 
        "public_test_cases": true, 
        "checker_program": null, 
        "topics": [], 
        "time_left": null, 
        "updated_at": "2016-09-01T16:38:21.000Z", 
        "author_name": "jspha", 
        "has_started": true, 
        "epoch_starttime": null, 
        "has_all_test_cases_public": false, 
        "difficulty_name": "Expert", 
        "require_unlock": true, 
        "body_html": "<div class='challenge_problem_statement'><div class='msB challenge_problem_statement_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>This challenge asks you to write a program which computes cellular automata state in a non-standard world. Instead of each cell living on a grid it lives on a binary tree.  </p>\n\n<h3>Overview</h3>\n\n<p>A Cellular Automaton (CA) is a set of <em>cells</em> which evolve together in stages.  At each stage, a given cell changes according to a given <em>rule</em> which depends upon values of cells in its <em>neighborhood</em>.  </p>\n\n<p>Commonly, CAs consist of a <em>grid</em> of cells so that each cell has a neighborhood of 8 cells.  </p>\n\n<pre><code>1---2---3\n|   |   |\n4---X---5\n|   |   |\n6---7---8\n</code></pre>\n\n<p>The dynamics of a CA on a grid is thus determined by a way of mapping all 9 of the values near <code>X</code> to a new value which <code>X</code> takes in the next iteration.</p>\n\n<pre><code>rule(v(1), ..., v(8), v(X)) = ...\n</code></pre>\n\n<p>An example grid CA is <a href=\"http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\">Conway's <em>Game of Life</em></a> which stores boolean values at each cell and has the following update rule:</p>\n\n<pre><code>Consider the sum N = v(1) + ... + v(8).\nIf v(X) then\n    If N &lt; 2 : return False\n    If N &gt; 3 : return False\n    otherwise : return True\nelse\n    If N == 3 : return True\n</code></pre>\n\n<p>A Game is played by picking an initial state of the grid and updating each cell according to the given rule repeatedly. Conway's rule produces startlingly interesting behavior for many initial states\u2014in fact, given an infinite grid there exist starting states which compute an encoding of any computable function. In other words, the Game of Life is <em>Turing complete</em>.</p>\n\n<p><strong>Rule encoding</strong>  </p>\n\n<p>CA update rules can be complex, but oftentimes they are serialized to a simple format.</p>\n\n<p>Most of the time there are only finitely many possible CA rules. Rules over binary-valued cells are usually assigned numbers by extending an ordering on the neighborhood of cells. For example, if we consider a linear automaton then the neighborhood of a cell looks like</p>\n\n<pre><code>1---X---2\n</code></pre>\n\n<p>a rule takes the form</p>\n\n<pre><code>(v(1), v(X), v(2)) -&gt; {0, 1}\n</code></pre>\n\n<p>and so if we assign an order to the input space we can write any such rule as a binary number</p>\n\n<pre><code>111 110 101 100 011 010 001 000\n-------------------------------\n 0   0   0   1   1   1   1   0    \"Rule 30\"\n 0   1   1   0   1   1   1   0    \"Rule 110\"\n</code></pre>\n\n<p>Clearly there are 256 such rules and so we can read any 8-bit number as a rule specification for a linear CA over binary values.</p>\n\n<h3>Problem statement</h3>\n\n<p>Instead of computing a CA on a grid, we'll compute a CA on a binary tree. The formulation of CAs above does not depend upon arranging the cells in a grid\u2014we can pick any topology so long as there's a notion of the <em>neighborhood</em> of a cell.</p>\n\n<p>So the task is to build a CA evaluator on binary trees. A conformant program should take a serialized binary tree and a rule (encoded as an integer) as input. Then, given a sequence of counts of iteration steps and associated \"paths\" into the tree the evaluator must <em>interactively</em> print out the binary value stored in the tree at the given path after the specified number of steps.  </p>\n\n<p>Importantly, while paths are guaranteed to always be valid, step counts are <em>not guaranteed</em> to always be <em>positive</em>. We may ask you travel back in time---though never beyond the beginning of time.</p>\n\n<p><strong>1. Parsing trees</strong>  </p>\n\n<p>The initial state of the binary tree automaton is a non-empty binary tree. A conformant program should parse its initial state from a format like as follows</p>\n\n<pre><code>X              --&gt; A leaf containing a single \"on\" cell\n\n.              --&gt; A leaf containing a single \"off\" cell\n\n(X . .)        --&gt; A branch holding an \"off\" with\n                      An \"on\" leaf as the left subtree\n                      An \"off\" leaf as the right subtree\n\n(X . (X . .))  --&gt; A branch with an \"off\" cell with\n                      An \"on\" leaf as the left subtree\n                      The prior example as the right subtree\n</code></pre>\n\n<p><strong>2. Parsing rules</strong>  </p>\n\n<p>The behavior of the automaton is governed by a choice of update rule operating on the 4-cell (unbiased) neighborhood of each cell. There are thus 2^(2^4) = 2^16 = 65536 possible rules and a conformant program must determine the rule in force by evaluating a given 16 bit code given as an unsigned integer.</p>\n\n<p>In pictures, the (maximal) neighborhood of a cell in a binary tree looks like and is numbered like</p>\n\n<pre><code>    (1)\n     |\n    (3)\n   /   \\\n (2)   (4)\n</code></pre>\n\n<p>and we'll encode each rule as a big-endian 16-bit word beginning with\nthe big encoding the \"all on neighborhood\"</p>\n\n<pre><code>1111 1110 1101 1100 1011 1010 1001 1000 ...\n_    _    _    _    _    _    _    _\n</code></pre>\n\n<p>Here are a few examples:</p>\n\n<pre><code>Rule 7710: (An analogue of Rule 30)\n  (X X X X)   --&gt;   .\n  (X X X .)   --&gt;   .\n  (X X . X)   --&gt;   .\n  (X X . .)   --&gt;   X\n  (X . X X)   --&gt;   X\n  (X . X .)   --&gt;   X\n  (X . . X)   --&gt;   X\n  (X . . .)   --&gt;   .\n  (. X X X)   --&gt;   .\n  (. X X .)   --&gt;   .\n  (. X . X)   --&gt;   .\n  (. X . .)   --&gt;   X\n  (. . X X)   --&gt;   X\n  (. . X .)   --&gt;   X\n  (. . . X)   --&gt;   X\n  (. . . .)   --&gt;   .\n\nRule 42354:\n  (X X X X)   --&gt;   X\n  (X X X .)   --&gt;   .\n  (X X . X)   --&gt;   X\n  (X X . .)   --&gt;   .\n  (X . X X)   --&gt;   .\n  (X . X .)   --&gt;   X\n  (X . . X)   --&gt;   .\n  (X . . .)   --&gt;   X\n  (. X X X)   --&gt;   .\n  (. X X .)   --&gt;   X\n  (. X . X)   --&gt;   X\n  (. X . .)   --&gt;   X\n  (. . X X)   --&gt;   .\n  (. . X .)   --&gt;   .\n  (. . . X)   --&gt;   X\n  (. . . .)   --&gt;   .\n</code></pre>\n\n<p><strong>3. Parsing Paths</strong>  </p>\n\n<p>Paths are pointers into a tree. The simplest path is the empty path\nwhich points to the root value of the tree. From there, they are\nmerely sequences of directions, left (denoted by the single character <code>&lt;</code>) and right (denoted by <code>&gt;</code>). Some example paths are</p>\n\n<pre><code>[&lt;&gt;&lt;&lt;&lt;&gt;&lt;&gt;&gt;]\n[&gt;&gt;&gt;&lt;&lt;&gt;&lt;]\n[]\n[&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;]\n</code></pre>\n\n<p>where the third example was the empty path.</p>\n\n<h3>Full input specification</h3>\n\n<p>A conformant program works as follows. First, it reads two lines\nsetting up the initial state: a rule integer and a serialized binary\ntree. The next line contains a natural number, <em>n  (1 &lt;= n &lt;= 1100)</em>, indicating the number of queries that will be asked.</p>\n\n<p>Then, it begins to execute the <em>n</em> queries. It reads a single line\nindicating the first query and must immediately print out the value\nstored at the path in the tree after the indicated number of rule\niterations followed by a newline. For cells which are \"on\", emit a <code>X</code>\nand for those which are \"off\" emit a <code>.</code>. This repeats <em>n-1</em> more\ntimes.</p>\n\n<p>An example transcript follows where lines sent from the server are\npreceeded by <code>&gt;</code> and lines returned from the client are preceeded by\n<code>&lt;</code>.</p>\n\n<pre><code>&gt; 42354\n&gt; ((. X (. . .)) . (X . (. X X)))\n&gt; 6\n&gt; 0 []\n&lt; .\n&gt; 2 [&gt;&lt;]\n&lt; X\n&gt; 0 [&gt;&lt;]\n&lt; X\n&gt; 0 [&lt;&gt;]\n&lt; .\n&gt; 1 [&gt;&lt;]\n&lt; X\n&gt; 0 [&lt;&gt;]\n&lt; X\n</code></pre>\n\n<p>For rule <code>r</code>, number of cases <code>n</code>, and step increments <code>s</code> we have <code>0 &lt;= r &lt;= 65535</code>, <code>1 &lt;= n &lt;= 1100</code>, and <code>-1000 &lt;= s &lt;= 1000</code>.</p>\n\n<p>To see a bit of what's going on behind the scenes, here are snapshots of the first 5 tree states at times [0, 4]</p>\n\n<pre><code>0 -- ((. X (. . .)) . (X . (. X X)))\n1 -- ((X . (. X .)) X (. X (X . X)))\n2 -- ((. X (X . X)) . (X X (. X .)))\n3 -- ((X . (. X .)) X (X . (X X X)))\n4 -- ((. X (X . X)) . (. X (X . X)))\n</code></pre>\n\n<p><strong>Sample Input</strong>  </p>\n\n<pre><code>42354\n((. X (. . .)) . (X . (. X X)))\n6\n0 []\n2 [&gt;&lt;]\n0 [&gt;&lt;]\n0 [&lt;&gt;]\n1 [&gt;&lt;]\n0 [&lt;&gt;]\n</code></pre>\n\n<p><strong>Sample Output</strong>  </p>\n\n<pre><code>.\nX\nX\n.\nX\nX\n</code></pre>\n\n<p><br></p>\n\n<hr>\n\n<p><strong>Tested by</strong> <a href=\"/Javran\">Javran (Fang) Cheng</a></p></div></div></div>", 
        "hacker": {
            "username": "HackerRank", 
            "is_admin": true, 
            "id": 15055, 
            "avatar": "https://hrcdn.net/s3_pub/hr-avatars/4c95f96b-1ff9-46ed-98f8-cb3cb4ed8834/150x150.png"
        }, 
        "id": 3928, 
        "leaderboard_out_of_sync": null, 
        "has_ended": false, 
        "languages": [
            "haskell", 
            "clojure", 
            "scala", 
            "erlang", 
            "sbcl", 
            "ocaml", 
            "fsharp", 
            "racket", 
            "elixir"
        ], 
        "is_custom": false, 
        "compile_and_test": true, 
        "default_language": null, 
        "migrated_resource": null, 
        "submit_disabled": null, 
        "expert_solution_status": false, 
        "can_solve": true, 
        "company_id": null, 
        "custom": null, 
        "can_be_viewed": true, 
        "track": {
            "name": "Recursion", 
            "taxonomy": 3, 
            "track_slug": "fp", 
            "track_id": 5, 
            "track_name": "Functional Programming", 
            "id": 26, 
            "rewards_system_enabled": null, 
            "slug": "fp-recursion"
        }, 
        "primary_contest": {
            "migration_status": null, 
            "contest_broadcast": null, 
            "hacker_timelimit": null, 
            "notification": null, 
            "qualification_rule_value": null, 
            "leaderboard_backend": null, 
            "expose_stats": null, 
            "updated_at": "2016-05-06T21:53:49.000Z", 
            "custom_leaderboard_column_name": null, 
            "organization_type": null, 
            "ended": true, 
            "epoch_starttime": 1409898600, 
            "timezone": "PST", 
            "disable_forum": false, 
            "id": 1109, 
            "primary_track_id": 5, 
            "limited_participants": null, 
            "school_leaderboard_enabled": false, 
            "time_limited_contest": false, 
            "archived": true, 
            "rated": false, 
            "parent_contest_id": null, 
            "leaderboard_out_of_sync_message": null, 
            "leaderboard_type": "country", 
            "tagline": "A contest for functional programming enthusiasts.", 
            "effective_epoch_endtime": 1410762600, 
            "show_participants_info": null, 
            "homepage_background_color": "", 
            "organization_name": null, 
            "track": {
                "name": "Functional Programming", 
                "id": 5, 
                "priority": 2, 
                "descriptions": "The art of programming with expressions and functions. Experience the challenge of programming without state. A good paradigm for those interested in Map-Reduce and parallel computing.", 
                "rewards_system_enabled": null, 
                "slug": "fp"
            }, 
            "primary_tag_id": null, 
            "hide_navigation": null, 
            "show_penalty": true, 
            "effective_time_left": -92594165.74924378, 
            "hidden": null, 
            "homepage": "", 
            "public": true, 
            "testers_contest": null, 
            "description": "The contest hosts 7 challenges ranging from algorithms to logics to compilers. \n<br><br>\n\n<strong>Problem Setters</strong> <a href=\"/pkacprzak\">Pawe\u0139 Kacprzak</a>, <a href=\"/jspha\">Joseph Abrahamson</a>, <a href=\"https://www.hackerrank.com/wanbo\">Wanbo</a>, <a href=\"/abhiranjan\">Abhiranjan</a>.\n<br><br>\n<strong>Validators</strong> <a href=\"https://www.hackerrank.com/Javran\">Javran (Fang) Cheng</a>, <a href=\"https://www.hackerrank.com/shaka_shadows\">Ray Williams Robinson Valiente</a>, <a href=\"https://www.hackerrank.com/wanbo\">Wanbo</a>, <a href=\"/abhiranjan\">Abhiranjan</a>.\n<br><br>\n<strong>Languages allowed</strong>: <i>Haskell, Scala, Lisp, Erlang, Clojure, OCaml and F#.</i>\n<br><br>\n<strong>Want to contribute problems?</strong> Mail to <a href=\"mailto:hackers@hackerrank.com?subject=Lambda Calculi\">hackers@hackerrank.com</a> with the subject \"Lambda Calculi\".", 
            "hide_difficulty": null, 
            "started": true, 
            "time_left": -92594165.74710585, 
            "challenges_count": 7, 
            "qualification_rule_msg": null, 
            "leaderboard_out_of_sync": null, 
            "team_event": false, 
            "disable_fsi": null, 
            "hide_submissions": null, 
            "leaderboard_format": "", 
            "leaderboard_broadcast_message": null, 
            "has_tracks": null, 
            "college_public": false, 
            "endtime": "2014-09-15T06:30:00.000Z", 
            "qualification_rule_type": null, 
            "slug": "lambda-calculi-sep14", 
            "hide_leaderboard": null, 
            "kind": "", 
            "comment_live_sync": null, 
            "name": "Functional Programming Contest - September'14", 
            "is_multi_round": false, 
            "created_at": "2014-07-22T16:27:04.000Z", 
            "epoch_endtime": 1410762600, 
            "company_associated_contest": null, 
            "rating_category": null, 
            "has_codesprint_reg_page": null, 
            "starttime": "2014-09-05T06:30:00.000Z", 
            "is_rating_updated": true, 
            "leaderboard_freeze_time": null, 
            "migration_disabled": null, 
            "template_id": 181
        }, 
        "factor": 200, 
        "is_solution_unlocked": false, 
        "preview": "Calculate cellular automata dynamics on a binary tree.", 
        "is_editorial_available": true, 
        "status": null, 
        "category": "ai", 
        "public_solutions": true, 
        "color": null, 
        "deleted": false, 
        "dynamic": true, 
        "company": null, 
        "moderator_or_support": false, 
        "is_text": false, 
        "solved_score": 0.5, 
        "difficulty_score": "0.186", 
        "difficulty": 0.1, 
        "active": true, 
        "show_skeliton": null, 
        "max_score": 200, 
        "slug": "the-tree-of-life", 
        "contest_slug": "master", 
        "user_score": 0, 
        "real_dynamic": false, 
        "kind": "code", 
        "player_count": 2, 
        "submitted_hackers_count": 235, 
        "name": "The Tree Of Life", 
        "is_preview_contest": false, 
        "level": 76, 
        "success_ratio": 0.8468085106382979, 
        "total_count": 235, 
        "created_at": "2014-08-23T15:16:42.000Z", 
        "epoch_endtime": null, 
        "judgebot": null, 
        "available_translations": [], 
        "codechecker_handle": null, 
        "countdown_time": 0, 
        "author_avatar": "https://secure.gravatar.com/avatar/2bc1bffafe7aa29ef900b98d1fd1e94e?d=https://d3rpyts3de3lx8.cloudfront.net/hackerrank/assets/gravatar.jpg&s=150", 
        "custom_tabs": null, 
        "judgebot_language": null, 
        "custom_case": true, 
        "requirements_description": null, 
        "is_skip_band_challenge": false, 
        "custom_checker_language": null
    }
}