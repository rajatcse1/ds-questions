{
    "status": true, 
    "model": {
        "onboarding": null, 
        "tagAncestry": [], 
        "solved_count": 65, 
        "leaderboard_out_of_sync_message": null, 
        "public_test_cases": true, 
        "checker_program": null, 
        "topics": [], 
        "time_left": null, 
        "updated_at": "2016-09-01T16:43:01.000Z", 
        "author_name": "pbl64k", 
        "has_started": true, 
        "epoch_starttime": null, 
        "has_all_test_cases_public": false, 
        "difficulty_name": "Expert", 
        "require_unlock": true, 
        "body_html": "<div class='challenge_problem_statement'><div class='msB challenge_problem_statement_body'><div class='hackdown-content'><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>Lambda calculus is a model of computation based on nothing but anonymous functions. Despite being one of the simplest and most elegant such models, it is perceived as a little too complicated by some. After all, it has function abstraction and variables! Combinatory logic, developed by Schonfinkel and Curry, is an equivalent model of computation that uses nothing but function application and a very small set of pre-defined combinators. Moreover, expressions of lambda calculus can be mechanically transformed to equivalent expressions in combinatory logic using a simple algorithm. Your task is to implement this algorithm.</p>\n\n<p><strong>Combinators</strong></p>\n\n<p>We will use the following combinators for the language of resulting combinatory logic expressions:</p>\n\n<pre><code>K = (\\x y. x)\n</code></pre>\n\n<p><em>K</em> is a constant function generator. Given some <em>x</em>, it evaluates to a function that evaluates to <em>x</em> for all inputs.</p>\n\n<pre><code>S = (\\x y z. ((x z) (y z)))\n</code></pre>\n\n<p><em>S</em> is a substitution function.</p>\n\n<p>Note that <em>S</em> and <em>K</em> alone form a Turing-complete model of computation. But for convenience we will use three other combinators as well.</p>\n\n<pre><code>I = (\\x. x)\n</code></pre>\n\n<p>Identity function. Extensionally equivalent to <em>SKK</em>.</p>\n\n<pre><code>B = (\\x y z. (x (y z)))\n</code></pre>\n\n<p><em>B</em> is function composition, aka \"<em>dot</em>\". Extensionally equivalent to <em>S(KS)K</em>.  </p>\n\n<pre><code>C = (\\x y z. ((x z) y))\n</code></pre>\n\n<p><em>C</em> returns a given binary function with its two parameters flipped. Extensionally equivalent to <em>S(S(K(S(KS)K))S)(KK)</em>.</p>\n\n<p><em>B</em> and <em>C</em> are specializations of <em>S</em>.  </p>\n\n<p><strong>Grammar for lambda calculus expressions</strong></p>\n\n<p>We will use a variant of lambda expression syntax for our inputs. The differences from the standard notation are as follows:</p>\n\n<ol>\n<li>Lowercase lambda in lambda expressions is represented by a backslash ('<code>\\</code>').</li>\n<li>Function applications must be parenthesized.</li>\n<li>Lambda expressions must be parenthesized.</li>\n<li>Lambda expressions are extended to easily formulate functions of arbitrary arity (in fully curried form). <code>(\\x y z. ((z y) x))</code> is equivalent to <code>(\\x. (\\y. (\\z. ((z y) x))))</code></li>\n</ol>\n\n<p>Variable names are represented by arbitrary non-empty sequences of Latin upper- and lowercase letters, numbers and underscores. Other tokens are '<code>(</code>', '<code>)</code>', '<code>\\</code>' and '<code>.</code>'. Tokens may be separated by arbitrary amount of whitespace without changing the meaning. Whitespace is required in some contexts, as described below.</p>\n\n<pre><code>EXP = VAR\nEXP = '(' EXP ' ' EXP ')'\nEXP = '(' '\\' VARLIST '.' EXP ')'\nVARLIST = VAR VARLIST0\nVARLIST0 = eps\nVARLIST0 = ' ' VAR VARLIST0\n</code></pre>\n\n<p><strong>Abstraction elimination algorithm</strong></p>\n\n<p>Use the version with rules for <em>S</em>, <em>K</em>, <em>I</em>, <em>B</em>, <em>C</em> at:  </p>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Abstraction_elimination#Combinators_B.2C_C\">http://en.wikipedia.org/wiki/Abstraction_elimination#Combinators_B.2C_C</a></p>\n\n<p>Apply eta-reduction wherever possible:  </p>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Abstraction_elimination#.CE.B7-reduction\">http://en.wikipedia.org/wiki/Abstraction_elimination#.CE.B7-reduction</a></p>\n\n<p>Eta-reduction removes unnecessary abstraction, making use of the fact that <code>(\\x. (E x))</code> is equivalent to <code>E</code>.</p>\n\n<p><strong>Free variables in lambda calculus</strong></p>\n\n<p>Performing abstraction elimination requires determining the free variables of a given expression. In lambda calculus, a variable is free in an expression if it's not a parameter in any of the enclosing lambda expressions. The opposite of a free variable is a bound variable. For example:</p>\n\n<pre><code>(\\x. (z (\\y. (y x)))\n</code></pre>\n\n<p>In this expression, <code>z</code> is a free variable, while <code>x</code> and <code>y</code> are bound variables. If we consider just the following sub-expression:</p>\n\n<pre><code>(z (\\y. (y x))\n</code></pre>\n\n<p>...then only <code>y</code> is a bound variable in it. Both <code>x</code> and <code>z</code> are free variables in this expression.</p>\n\n<p><strong>Input</strong>  </p>\n\n<p>First line contains number of test cases, 1 &lt;= <em>T</em> &lt;= 100. <em>T</em> lines follow. Each line contains a lambda expression. Lambda expressions in the test cases contain no free variables at the top level. This ensures that the equivalent combinatory logic expression can be written using nothing but the five combinators listed above.</p>\n\n<p><strong>Output</strong>  </p>\n\n<p>Output <em>T</em> lines with equivalent representations of given lambda expressions in SKIBC-basis combinatory logic.  </p>\n\n<p><strong>Sample Input</strong>  </p>\n\n<pre><code>3\n(\\x. x)\n(\\test. (\\ignored_1. test))\n(\\x. (\\y. (y (\\z. (\\t. ((z (\\x. x)) x))))))\n</code></pre>\n\n<p><strong>Sample Output</strong>  </p>\n\n<pre><code>I\nK\nB(CI)(B(BK)(C(CII)))    \n</code></pre>\n\n<p><strong>Notes</strong>  </p>\n\n<p>When outputting the results, consider function application to be left-associative and do not output superfluous parentheses.  </p>\n\n<p>There are infinitely many combinatory logic expressions that are extensionally equivalent to a given lambda expression. Moreover, the problem of determining extensional equivalence is undecidable. To pass the test cases, use the algorithm as outlined on the linked page, using all five combinators, and performing eta-conversion whenever possible. </p></div></div></div>", 
        "hacker": {
            "username": "HackerRank", 
            "is_admin": true, 
            "id": 15055, 
            "avatar": "https://hrcdn.net/s3_pub/hr-avatars/4c95f96b-1ff9-46ed-98f8-cb3cb4ed8834/150x150.png"
        }, 
        "id": 2502, 
        "leaderboard_out_of_sync": null, 
        "has_ended": false, 
        "languages": [
            "haskell", 
            "clojure", 
            "scala", 
            "erlang", 
            "sbcl", 
            "ocaml", 
            "fsharp", 
            "racket", 
            "elixir"
        ], 
        "is_custom": false, 
        "compile_and_test": true, 
        "default_language": null, 
        "migrated_resource": null, 
        "submit_disabled": null, 
        "expert_solution_status": false, 
        "can_solve": true, 
        "company_id": null, 
        "custom": null, 
        "can_be_viewed": true, 
        "track": {
            "name": "Interpreter and Compilers", 
            "taxonomy": 3, 
            "track_slug": "fp", 
            "track_id": 5, 
            "track_name": "Functional Programming", 
            "id": 48, 
            "rewards_system_enabled": null, 
            "slug": "compilers"
        }, 
        "primary_contest": {
            "migration_status": null, 
            "contest_broadcast": null, 
            "hacker_timelimit": null, 
            "notification": null, 
            "qualification_rule_value": null, 
            "leaderboard_backend": null, 
            "expose_stats": null, 
            "updated_at": "2016-05-06T21:52:10.000Z", 
            "custom_leaderboard_column_name": null, 
            "organization_type": null, 
            "ended": true, 
            "epoch_starttime": 1400221800, 
            "timezone": "PST", 
            "disable_forum": null, 
            "id": 860, 
            "primary_track_id": 5, 
            "limited_participants": null, 
            "school_leaderboard_enabled": false, 
            "time_limited_contest": false, 
            "archived": true, 
            "rated": true, 
            "parent_contest_id": null, 
            "leaderboard_out_of_sync_message": null, 
            "leaderboard_type": "country", 
            "tagline": "A contest for functional programming enthusiasts.", 
            "effective_epoch_endtime": 1401085800, 
            "show_participants_info": null, 
            "homepage_background_color": "", 
            "organization_name": null, 
            "track": {
                "name": "Functional Programming", 
                "id": 5, 
                "priority": 2, 
                "descriptions": "The art of programming with expressions and functions. Experience the challenge of programming without state. A good paradigm for those interested in Map-Reduce and parallel computing.", 
                "rewards_system_enabled": null, 
                "slug": "fp"
            }, 
            "primary_tag_id": null, 
            "hide_navigation": null, 
            "show_penalty": null, 
            "effective_time_left": -102271088.4237354, 
            "hidden": null, 
            "homepage": "", 
            "public": true, 
            "testers_contest": null, 
            "description": "Functional programming is an elegant programming style where we use functional languages to write mathematically pure functions. The outputs of these pure functions depend only on the input parameters and not on the state of the program. Hence, these programs have almost negligible side effects. <br /> \n  \nYou can solve this contest in any of these functional languages: <i>Haskell, Scala, Lisp, Erlang, Clojure, OCaml and F#</i>.", 
            "hide_difficulty": null, 
            "started": true, 
            "time_left": -102271088.41662285, 
            "challenges_count": 5, 
            "qualification_rule_msg": null, 
            "leaderboard_out_of_sync": null, 
            "team_event": false, 
            "disable_fsi": null, 
            "hide_submissions": null, 
            "leaderboard_format": "", 
            "leaderboard_broadcast_message": null, 
            "has_tracks": null, 
            "college_public": null, 
            "endtime": "2014-05-26T06:30:00.000Z", 
            "qualification_rule_type": null, 
            "slug": "lambda-calculi-may14", 
            "hide_leaderboard": null, 
            "kind": null, 
            "comment_live_sync": null, 
            "name": "Functional Programming Contest - May'14", 
            "is_multi_round": false, 
            "created_at": "2014-04-23T20:32:20.000Z", 
            "epoch_endtime": 1401085800, 
            "company_associated_contest": null, 
            "rating_category": "Functional Programming", 
            "has_codesprint_reg_page": null, 
            "starttime": "2014-05-16T06:30:00.000Z", 
            "is_rating_updated": true, 
            "leaderboard_freeze_time": null, 
            "migration_disabled": null, 
            "template_id": 147
        }, 
        "factor": 150, 
        "is_solution_unlocked": false, 
        "preview": null, 
        "is_editorial_available": false, 
        "status": null, 
        "category": "ai", 
        "public_solutions": true, 
        "color": null, 
        "deleted": false, 
        "dynamic": true, 
        "company": null, 
        "moderator_or_support": false, 
        "is_text": false, 
        "solved_score": 0.5, 
        "difficulty_score": "0.13", 
        "difficulty": 0.1, 
        "active": true, 
        "show_skeliton": null, 
        "max_score": 150, 
        "slug": "down-with-abstractions", 
        "contest_slug": "master", 
        "user_score": 0, 
        "real_dynamic": false, 
        "kind": "code", 
        "player_count": 2, 
        "submitted_hackers_count": 72, 
        "name": "Down With Abstractions", 
        "is_preview_contest": false, 
        "level": 93, 
        "success_ratio": 0.9027777777777778, 
        "total_count": 72, 
        "created_at": "2014-05-10T10:49:25.000Z", 
        "epoch_endtime": null, 
        "judgebot": null, 
        "available_translations": [], 
        "codechecker_handle": null, 
        "countdown_time": 0, 
        "author_avatar": "https://hrcdn.net/s3_pub/hr-avatars/5b3f3b84-cbde-4e65-94d7-8c228366e188/150x150.png", 
        "custom_tabs": null, 
        "judgebot_language": null, 
        "custom_case": true, 
        "requirements_description": null, 
        "is_skip_band_challenge": false, 
        "custom_checker_language": null
    }
}