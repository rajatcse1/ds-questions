{
    "models": [
        {
            "onboarding": null, 
            "solved_count": 4725, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-06-08T06:46:04.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 25952, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 30, 
            "is_solution_unlocked": false, 
            "preview": "Help the ruler of HackerLand determine the cheapest way to give his citizens access to libraries.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 30, 
            "slug": "torque-and-development", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Roads and Libraries", 
            "level": 30, 
            "success_ratio": 0.638340988921913, 
            "total_count": 7402, 
            "created_at": "2016-10-01T05:57:36.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 10537, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:55:37.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 784, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Compute in how many ways we can pick a pair of astronauts belonging to different countries", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.6280068728522337, 
            "active": true, 
            "max_score": 50, 
            "slug": "journey-to-the-moon", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Journey to the Moon", 
            "level": 35, 
            "success_ratio": 0.5953107344632769, 
            "total_count": 17700, 
            "created_at": "2013-07-31T03:31:09.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 812, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:52:11.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 19049, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 40, 
            "is_solution_unlocked": false, 
            "preview": "Find the optimal time for buying all the specified items.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 40, 
            "slug": "synchronous-shopping", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Synchronous Shopping", 
            "level": 50, 
            "success_ratio": 0.44106463878326996, 
            "total_count": 1841, 
            "created_at": "2016-03-12T18:06:32.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 556, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:43:35.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 774, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Find the sum of the number of connected component(S) in every graph.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.49074074074074076, 
            "active": true, 
            "max_score": 50, 
            "slug": "subset-component", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Subset Component", 
            "level": 37, 
            "success_ratio": 0.4707874682472481, 
            "total_count": 1181, 
            "created_at": "2013-07-23T07:50:45.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 24642, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:48:20.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 5580, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 55, 
            "is_solution_unlocked": false, 
            "preview": "Implement a Breadth First Search (BFS).", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 55, 
            "slug": "bfsshortreach", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Breadth First Search: Shortest Reach", 
            "level": 49, 
            "success_ratio": 0.7644485807352257, 
            "total_count": 32235, 
            "created_at": "2014-12-18T09:52:42.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 6533, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:48:29.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 5686, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Learn to use the Kruskal's algorithm !", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 50, 
            "slug": "kruskalmstrsub", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Kruskal (MST): Really Special Subtree", 
            "level": 49, 
            "success_ratio": 0.828745401496892, 
            "total_count": 7883, 
            "created_at": "2014-12-26T13:31:43.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 20085, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:45.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 110, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Can you kill the most edges to turn a tree into a forest of even trees?", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 50, 
            "slug": "even-tree", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Even Tree", 
            "level": 46, 
            "success_ratio": 0.8911220551044856, 
            "total_count": 22539, 
            "created_at": "2013-01-04T20:29:48.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 8558, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:43:02.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 626, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Given the configuration of a Snakes and Ladders board, what is the shortest number of rolls of the die in which a player can reach the destination square?", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 50, 
            "slug": "the-quickest-way-up", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Snakes and Ladders: The Quickest Way Up", 
            "level": 47, 
            "success_ratio": 0.749124649859944, 
            "total_count": 11424, 
            "created_at": "2013-04-27T06:18:50.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 8449, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:48:23.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 5595, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Learn to use Dijkstra's shortest path algorithm !", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 60, 
            "slug": "dijkstrashortreach", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Dijkstra: Shortest Reach 2", 
            "level": 57, 
            "success_ratio": 0.6142493638676845, 
            "total_count": 13755, 
            "created_at": "2014-12-19T07:54:20.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 172, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-02-18T11:25:36.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 29036, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Help Alice find the probability of winning a game played on a Tree with Bob.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 50, 
            "slug": "the-story-of-a-tree", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "The Story of a Tree", 
            "level": 50, 
            "success_ratio": 0.455026455026455, 
            "total_count": 378, 
            "created_at": "2016-11-28T19:34:31.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 7528, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:48:26.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 5670, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Learn to use Prim's algorithm !", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 60, 
            "slug": "primsmstsub", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Prim's (MST) : Special Subtree", 
            "level": 58, 
            "success_ratio": 0.8071191165433688, 
            "total_count": 9327, 
            "created_at": "2014-12-25T09:39:20.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 35, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-03-02T12:08:53.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 19177, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "For each digit from 0 to 9, find the number ordered pairs of paths where the total cost of the tolls ends in that specific digit.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 60, 
            "slug": "toll-cost-digits", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Toll Cost Digits", 
            "level": 50, 
            "success_ratio": 0.47297297297297297, 
            "total_count": 74, 
            "created_at": "2016-03-15T02:51:17.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 63, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2016-11-20T11:30:31.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 28277, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Sell as many houses as is possible!", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 60, 
            "slug": "real-estate-broker", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Real Estate Broker", 
            "level": 50, 
            "success_ratio": 0.4117647058823529, 
            "total_count": 153, 
            "created_at": "2016-11-15T05:15:02.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 1535, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:12.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 54, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Find the minimum size of the largest clique in a graph.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.6723646723646723, 
            "active": true, 
            "max_score": 60, 
            "slug": "clique", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Clique", 
            "level": 59, 
            "success_ratio": 0.5749063670411985, 
            "total_count": 2670, 
            "created_at": "2013-01-04T20:25:28.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 481, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:51:59.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 17276, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Find the most beautiful path.\n", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 50, 
            "slug": "beautiful-path", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Minimum Penalty Path", 
            "level": 30, 
            "success_ratio": 0.3666158536585366, 
            "total_count": 1312, 
            "created_at": "2016-02-13T07:45:52.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 84, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:53:15.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 22036, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Find out the maximal amount of money it's possible to borrow.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 50, 
            "slug": "borrowing-money", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Demanding Money", 
            "level": 50, 
            "success_ratio": 0.33070866141732286, 
            "total_count": 254, 
            "created_at": "2016-06-06T21:29:54.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 64, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-02-15T09:16:31.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 22938, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 55, 
            "is_solution_unlocked": false, 
            "preview": "Find the maximum total value of friendships between students.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 55, 
            "slug": "value-of-friendship", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "The Value of Friendship", 
            "level": 50, 
            "success_ratio": 0.4155844155844156, 
            "total_count": 154, 
            "created_at": "2016-07-15T13:59:13.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 8, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2016-12-20T09:52:52.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 25664, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Find the number of coprime pairs on a path of a graph.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 80, 
            "slug": "coprime-paths", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Coprime Paths", 
            "level": 85, 
            "success_ratio": 0.1702127659574468, 
            "total_count": 47, 
            "created_at": "2016-09-25T13:18:22.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 22, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-02-17T16:59:41.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 24474, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Help Allison sum the lengths of the edges in her graph.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 80, 
            "slug": "minimum-mst-graph", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Minimum MST Graph", 
            "level": 80, 
            "success_ratio": 0.3142857142857143, 
            "total_count": 70, 
            "created_at": "2016-09-01T21:28:54.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 1205, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:44:03.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 924, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Find out the most cost efficient way to go from the first station to the last station.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.625, 
            "active": true, 
            "max_score": 80, 
            "slug": "jack-goes-to-rapture", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Jack goes to Rapture ", 
            "level": 43, 
            "success_ratio": 0.5519926706367384, 
            "total_count": 2183, 
            "created_at": "2013-09-17T12:03:18.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 387, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:26.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 71, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "Crab graphs have 1 head and K feet. Find crab graphs within a graph with the maximum total number of vertices.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.651685393258427, 
            "active": true, 
            "max_score": 50, 
            "slug": "crab-graphs", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Crab Graphs", 
            "level": 74, 
            "success_ratio": 0.6428571428571429, 
            "total_count": 602, 
            "created_at": "2013-01-04T20:26:44.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 381, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:42:09.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 339, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 70, 
            "is_solution_unlocked": false, 
            "preview": "Find out how many different ornaments can be created with the given algorithm?", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.3, 
            "active": true, 
            "max_score": 70, 
            "slug": "beadornaments", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Bead Ornaments", 
            "level": 55, 
            "success_ratio": 0.7665995975855131, 
            "total_count": 497, 
            "created_at": "2013-02-01T21:09:34.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 255, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:50:34.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 9931, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Find the minimum distance Jeanie must travel to deliver all her letters.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 80, 
            "slug": "jeanies-route", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Jeanie's Route", 
            "level": 50, 
            "success_ratio": 0.5835240274599542, 
            "total_count": 437, 
            "created_at": "2015-08-20T13:51:30.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 4380, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:48:30.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 5697, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 75, 
            "is_solution_unlocked": false, 
            "preview": "Learn to use Floyd Warshall's algorithm !", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 75, 
            "slug": "floyd-city-of-blinding-lights", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Floyd : City of Blinding Lights", 
            "level": 70, 
            "success_ratio": 0.8047032886275951, 
            "total_count": 5443, 
            "created_at": "2014-12-26T20:38:53.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 243, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:51:06.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 14676, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Help John to calculate sum of minimum distances of each pair of cities. ", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 60, 
            "slug": "johnland", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Roads in HackerLand", 
            "level": 0, 
            "success_ratio": 0.3135483870967742, 
            "total_count": 775, 
            "created_at": "2015-11-21T19:07:24.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 1070, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:32.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 84, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 75, 
            "is_solution_unlocked": false, 
            "preview": "How many paths are there between two given cities in a graphs? The paths can repeat over the same road.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.45951283739302173, 
            "active": true, 
            "max_score": 75, 
            "slug": "kingdom-connectivity", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Kingdom Connectivity", 
            "level": 72, 
            "success_ratio": 0.47366091190792387, 
            "total_count": 2259, 
            "created_at": "2013-01-04T20:27:34.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 89, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:43:27.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 744, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Find out the maximal number of times Sophia can remove a pair (Ai, Bj) from the array if they are not co-prime.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5135135135135135, 
            "active": true, 
            "max_score": 80, 
            "slug": "computer-game", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Computer Game", 
            "level": 65, 
            "success_ratio": 0.13734567901234568, 
            "total_count": 648, 
            "created_at": "2013-07-01T13:28:25.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 731, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:48:19.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 5545, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 70, 
            "is_solution_unlocked": false, 
            "preview": "Calculate the shortest distance from Rust's position (Node S) to all the other places in the city ", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 70, 
            "slug": "rust-murderer", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Rust & Murderer", 
            "level": 70, 
            "success_ratio": 0.4588826114249843, 
            "total_count": 1593, 
            "created_at": "2014-12-14T09:51:27.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": ""
        }, 
        {
            "onboarding": null, 
            "solved_count": 510, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:17.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 60, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "You need to complete problems which are sorted by difficulty and given numbered by variety. Each day you need to do the problems in increasing difficulty and with a minimum level of variety. What is the minimum number of days it can be completed in?", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.515625, 
            "active": true, 
            "max_score": 80, 
            "slug": "problem-solving", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Problem solving", 
            "level": 63, 
            "success_ratio": 0.46875, 
            "total_count": 1088, 
            "created_at": "2013-01-04T20:25:56.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 121, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:47:59.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 5186, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 75, 
            "is_solution_unlocked": false, 
            "preview": "Help Fedya to find the distance he'll travel in his journey.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 75, 
            "slug": "journey-scheduling", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Journey Scheduling", 
            "level": 74, 
            "success_ratio": 0.4618320610687023, 
            "total_count": 262, 
            "created_at": "2014-11-14T21:01:08.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 946, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:35.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 93, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 70, 
            "is_solution_unlocked": false, 
            "preview": "Machines are attacking! You need to destroy enough roads so no two machines are can reach each other. Find the roads to destroy in the least amount of time.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5970695970695971, 
            "active": true, 
            "max_score": 70, 
            "slug": "matrix", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Matrix", 
            "level": 71, 
            "success_ratio": 0.5938480853735091, 
            "total_count": 1593, 
            "created_at": "2013-01-04T20:28:22.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 25, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:52:01.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 17340, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 70, 
            "is_solution_unlocked": false, 
            "preview": "Given schedules for each season of Dave's favorite show, find the maximum number of consecutive episodes he can record from each season.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 70, 
            "slug": "episode-recording", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Recording Episodes", 
            "level": 50, 
            "success_ratio": 0.32894736842105265, 
            "total_count": 76, 
            "created_at": "2016-02-15T12:40:25.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 192, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:14.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 57, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "You need to send robots through every road in Byteland without any road being visited twice. How many robots are needed?", 
            "is_editorial_available": false, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.4857142857142857, 
            "active": true, 
            "max_score": 80, 
            "slug": "repair-roads", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Repair Roads", 
            "level": 77, 
            "success_ratio": 0.37209302325581395, 
            "total_count": 516, 
            "created_at": "2013-01-04T20:25:41.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 503, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:43:46.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 791, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 90, 
            "is_solution_unlocked": false, 
            "preview": "Figure out the K-th parent of a node at any instant.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.43529411764705883, 
            "active": true, 
            "max_score": 90, 
            "slug": "kth-ancestor", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Kth Ancestor", 
            "level": 86, 
            "success_ratio": 0.43324720068906114, 
            "total_count": 1161, 
            "created_at": "2013-08-01T18:06:31.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 236, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:09.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 52, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": null, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": null, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 90, 
            "is_solution_unlocked": false, 
            "preview": "In how many ways can a travelling salesman visit every city once?", 
            "is_editorial_available": false, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5851851851851851, 
            "active": true, 
            "max_score": 90, 
            "slug": "bytelandian-tours", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "ByteLandian Tours", 
            "level": 87, 
            "success_ratio": 0.5363636363636364, 
            "total_count": 440, 
            "created_at": "2013-01-04T20:25:21.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 26, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:51:10.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 14770, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 75, 
            "is_solution_unlocked": false, 
            "preview": "Answer 30000 queries \"find shortest path between cell in  7*5000 table\"", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 75, 
            "slug": "shortest-path", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Find the Path", 
            "level": 75, 
            "success_ratio": 0.13333333333333333, 
            "total_count": 195, 
            "created_at": "2015-11-25T21:07:09.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 144, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:46:59.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 3242, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 90, 
            "is_solution_unlocked": false, 
            "preview": "Savita and Friends are meeting after a long time. Help Savita to organize the meeting.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 90, 
            "slug": "savita-and-friends", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Savita And Friends", 
            "level": 82, 
            "success_ratio": 0.602510460251046, 
            "total_count": 239, 
            "created_at": "2014-07-08T10:47:13.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 186, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:36.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 96, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 85, 
            "is_solution_unlocked": false, 
            "preview": "Some of your soldiers are liars! You are given the number of liars amongst certain ranges. Find the minimum and maximum number of liars amongst your soldiers.", 
            "is_editorial_available": false, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.3813559322033898, 
            "active": true, 
            "max_score": 85, 
            "slug": "liars", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Liars", 
            "level": 82, 
            "success_ratio": 0.43661971830985913, 
            "total_count": 426, 
            "created_at": "2013-01-04T20:28:32.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 23, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:53:48.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 24358, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Put k rooks on an n &times; n table with impassable cells in such a way that the number of pairs of rooks beating each other minimal. A rook beats another rook if they share a row or a column and there are no impassable cells between them.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.3, 
            "active": true, 
            "max_score": 80, 
            "slug": "jumping-rooks", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Jumping Rooks", 
            "level": 70, 
            "success_ratio": 0.2804878048780488, 
            "total_count": 82, 
            "created_at": "2016-08-30T13:52:08.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 39, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:52:52.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 21484, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Given three graphs, find number of $(a, b, c)$ triples such that there is an edge $(a, b)$ in $G_1$, an edge $(b, c)$ in $G_2$, and an edge $(c, a)$ in $G_3$.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 80, 
            "slug": "tripartite-matching", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Tripartite Matching", 
            "level": 50, 
            "success_ratio": 0.312, 
            "total_count": 125, 
            "created_at": "2016-05-13T18:43:38.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 39, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:52:10.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 19024, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "You're given a weighted tree. Let's construct a complete graph: capacity of edge (u, v) is distance between u and v in tree. Find maximum flow in this graph.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 80, 
            "slug": "tree-flow", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Tree Flow", 
            "level": 60, 
            "success_ratio": 0.3305084745762712, 
            "total_count": 118, 
            "created_at": "2016-03-12T09:25:37.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 9, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2016-12-08T15:11:22.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 25943, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Process the queries on DAG", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 80, 
            "slug": "dag-queries", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "DAG Queries", 
            "level": 80, 
            "success_ratio": 0.1323529411764706, 
            "total_count": 68, 
            "created_at": "2016-09-30T23:23:09.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 374, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:47:19.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 3518, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": null, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": null, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 95, 
            "is_solution_unlocked": false, 
            "preview": "Help Johnny reconstruct his favorite sequence satisfying some conditions.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.36507936507936506, 
            "active": true, 
            "max_score": 95, 
            "slug": "favourite-sequence", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Favorite sequence", 
            "level": 90, 
            "success_ratio": 0.3789260385005066, 
            "total_count": 987, 
            "created_at": "2014-08-08T08:26:32.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 34, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:52:09.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 18769, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Find the number of unique paths Big and Little Cat can go jogging on.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.3, 
            "active": true, 
            "max_score": 80, 
            "slug": "cat-jogging", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Jogging Cats", 
            "level": 50, 
            "success_ratio": 0.2698412698412698, 
            "total_count": 126, 
            "created_at": "2016-03-09T13:22:42.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 579, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [
                {
                    "slug": "segment-tree", 
                    "title": "Segment Tree"
                }
            ], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:00.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 42, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "How many points on a grid lie in each quadrant? What happens after performing various reflection operations?", 
            "is_editorial_available": false, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.2502596053997923, 
            "active": true, 
            "max_score": 100, 
            "slug": "quadrant-queries", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Quadrant Queries", 
            "level": 97, 
            "success_ratio": 0.2602247191011236, 
            "total_count": 2225, 
            "created_at": "2013-01-04T20:24:42.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": ""
        }, 
        {
            "onboarding": null, 
            "solved_count": 169, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:44:53.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 1574, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "What is the minimum cost of a road trip in Hacker Country? ", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5333333333333333, 
            "active": true, 
            "max_score": 100, 
            "slug": "hacker-country", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Hacker Country", 
            "level": 93, 
            "success_ratio": 0.3650107991360691, 
            "total_count": 463, 
            "created_at": "2013-12-20T08:10:24.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 151, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:44:15.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 1090, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": null, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": null, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Find the minimum number of hackerX missiles you must launch to keep Nation B safe.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5384615384615384, 
            "active": true, 
            "max_score": 100, 
            "slug": "missile-defend", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "HackerX", 
            "level": 96, 
            "success_ratio": 0.31069958847736623, 
            "total_count": 486, 
            "created_at": "2013-10-16T17:50:34.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 25, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:45:58.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 2249, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": null, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": null, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Can you move the block to its exit in the minimum possible time?", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.125, 
            "active": true, 
            "max_score": 100, 
            "slug": "huarongdao", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Huarongdao", 
            "level": 95, 
            "success_ratio": 0.1404494382022472, 
            "total_count": 178, 
            "created_at": "2014-03-26T06:43:55.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 113, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:47:16.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 3437, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 120, 
            "is_solution_unlocked": false, 
            "preview": "Design a series of transformation which results into maximum number of skill set with non-zero acquaintance.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5454545454545454, 
            "active": true, 
            "max_score": 120, 
            "slug": "training-the-army", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Training the army", 
            "level": 88, 
            "success_ratio": 0.44664031620553357, 
            "total_count": 253, 
            "created_at": "2014-08-01T00:35:38.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 150, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:47:23.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 3585, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": null, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": null, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Jim is planning a LAN party in the basement of his big burger restaurant, but they stumbled upon a problem. Please help them.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 80, 
            "slug": "jim-and-his-lan-party", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Jim and his LAN Party", 
            "level": 78, 
            "success_ratio": 0.48859934853420195, 
            "total_count": 307, 
            "created_at": "2014-08-15T10:42:28.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 41, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:50:37.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 12233, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": ".", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 80, 
            "slug": "travel-in-hackerland", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Travel in HackerLand", 
            "level": 50, 
            "success_ratio": 0.4606741573033708, 
            "total_count": 89, 
            "created_at": "2015-09-13T21:08:52.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 112, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:47:05.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 3349, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 150, 
            "is_solution_unlocked": false, 
            "preview": "Calculate the probability of winning the described game playing randomly.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 150, 
            "slug": "alex-vs-fedor", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Alex vs Fedor", 
            "level": 91, 
            "success_ratio": 0.5137614678899083, 
            "total_count": 218, 
            "created_at": "2014-07-22T11:49:02.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 31, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:50:59.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 13888, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Find subset of the vertical paths in the tree with maximum sum of costs.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 100, 
            "slug": "vertical-paths", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Vertical Paths", 
            "level": 50, 
            "success_ratio": 0.484375, 
            "total_count": 64, 
            "created_at": "2015-10-28T20:46:50.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 14, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:44:52.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 1545, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 90, 
            "is_solution_unlocked": false, 
            "preview": "Find out the minimum sum of travelling time for all commuters in a bus under given conditions.", 
            "is_editorial_available": false, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 90, 
            "slug": "drive", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Drive", 
            "level": 85, 
            "success_ratio": 0.16470588235294117, 
            "total_count": 85, 
            "created_at": "2013-12-14T18:10:57.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 24, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:45:45.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 2109, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Whats the shortest time that the Travelling Salesman takes to travel in the grid?", 
            "is_editorial_available": false, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 100, 
            "slug": "tsp-grid", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Travelling Salesman in a Grid", 
            "level": 95, 
            "success_ratio": 0.09486166007905138, 
            "total_count": 253, 
            "created_at": "2014-03-13T07:03:00.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 161, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:45:58.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 2265, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 90, 
            "is_solution_unlocked": false, 
            "preview": "Find the product of separation numbers for all unordered pairs of cities in the country.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 90, 
            "slug": "road-network", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Road Network", 
            "level": 83, 
            "success_ratio": 0.5609756097560976, 
            "total_count": 287, 
            "created_at": "2014-03-27T19:16:58.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 141, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:41:33.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 86, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Every day another road gets blocked. What is the shortest path between 2 cities on a given day?", 
            "is_editorial_available": false, 
            "status": null, 
            "category": "algorithm", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1839863713798978, 
            "active": true, 
            "max_score": 100, 
            "slug": "going-office", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Going to the Office", 
            "level": 97, 
            "success_ratio": 0.167458432304038, 
            "total_count": 842, 
            "created_at": "2013-01-04T20:27:47.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 50, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:52:52.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 21497, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Maintain the sizes of connected components in a tree.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.3, 
            "active": true, 
            "max_score": 100, 
            "slug": "tree-splitting", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Tree Splitting", 
            "level": 50, 
            "success_ratio": 0.4424778761061947, 
            "total_count": 113, 
            "created_at": "2016-05-14T14:58:44.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 99, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:43:35.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 772, 
            "has_ended": false, 
            "is_custom": true, 
            "compile_and_test": true, 
            "checker_program": "import json\nfrom sys import stdin\n\ndef check_inputs (inputs, exp_outputs, act_outputs):\n    scores = []\n    valid = []\n    for i in range(len(inputs)):\n        if process_input(inputs[i], exp_outputs[i], act_outputs[i]):\n            scores.append(1)\n            valid.append(1)\n        else:\n            scores.append(0)\n            valid.append(0)\n    return valid, scores\n\ndef check_output_format(n,m,output):\n    try:\n        data = output.strip().split(\"\\n\")\n        if len(data) != n+1:\n            return False\n        float(data[0])\n        for i in range(1, n+1):\n            if not 1 <= int(data[i]) <= m:\n                return False\n    except:\n        return False\n\n    return True\n\ndef cal_score(dest_costs, person_dest, queue_order):\n    '''\n    calculates the score based on queue order\n    '''\n    cost = 0\n    for queue_num in queue_order:\n        queue_iter = 0\n        while queue_iter < len(queue_order[queue_num])-1:\n            old = queue_iter\n            while queue_iter < len(queue_order[queue_num])-1 and person_dest[queue_order[queue_num][queue_iter]] == person_dest[queue_order[queue_num][queue_iter+1]]:\n                queue_iter += 1\n\n            cost += dest_costs[person_dest[queue_order[queue_num][old]]]\n            if queue_iter != old:\n                cost += 0.8*dest_costs[person_dest[queue_order[queue_num][old]]]*(queue_iter-old)\n\n            queue_iter += 1\n        if queue_iter == len(queue_order[queue_num])-1:\n            cost += dest_costs[person_dest[queue_order[queue_num][queue_iter]]]\n    return cost\n\ndef process_input(input_data, expected_output, actual_output):\n    data = input_data.strip().split(\"\\n\")\n    n,m,k = map(int, data[0].split())\n    dest_costs = {}\n\n    for cost_index in range(1, k+1):\n        city, price = data[cost_index].split()\n        dest_costs[city] = int(price)\n\n    people_dest = []\n    for dest in range(k+1, 1 + k + n):\n        people_dest.append(data[dest])\n\n    exp_score = float(expected_output.strip().split(\"\\n\")[0])\n    out_split = actual_output.strip().split(\"\\n\")\n\n    if not check_output_format(n, m, actual_output):\n        return False\n\n    act_score = float(out_split[0])\n    queue_order = {}\n    temp_queue = map(int, out_split[1:])\n    for i in range(len(temp_queue)):\n        if queue_order.has_key(temp_queue[i]):\n            queue_order[temp_queue[i]].append(i)\n        else:\n            queue_order[temp_queue[i]] = [i]\n    cald_score = cal_score(dest_costs, people_dest, queue_order)\n\n    if abs(exp_score - act_score) <= 10**(-3) and abs(act_score - cald_score) <= 10**(-3):\n        return True\n\n    return False\n\ndef process(data):\n    # Whatever you do, I am not giving any marks!\n    score = 0.0\n    valid, scores = check_inputs(data[\"inputs\"], data[\"expected_outputs\"], data[\"outputs\"])\n    for s in scores:\n        score += s\n\n    return score/len(scores), valid\n\nif __name__ ==  '__main__':\n    stdin = stdin.read().split('\\n')\n\n    # Get the run directory for the submission we need to evaluate. I know,\n    # hackish right?\n\n    run_directory =stdin[-1]\n\n    # request.json contains the data submitted for the current.\n    request = json.load(open(run_directory + \"request.json\"))\n\n\n    data = {\n        # The submitted source code\n        \"source\": request[\"source\"],\n\n        # The list of test cases\n        \"testcases\": request[\"testcase_sources\"],\n\n        # The submitted language key (Eg: 5 for python)\n        \"lang\": request[\"lang\"],\n\n        # I'll tell you how to fill this next\n        \"expected_outputs\": request[\"expected_outputs\"],\n\n        \"outputs\": [],\n        \"inputs\": []\n    }\n\n    for index in range(len(request[\"testcase_sources\"])):\n        output = open(run_directory + \"output%05d.out\" %(index)).read()\n        inputs = open(run_directory + \"input%05d.in\" %(index)).read()\n        data[\"outputs\"].append(output)\n        data[\"inputs\"].append(inputs)\n\n    # Gathered all the data we could, lets process it\n    score, testcase_status = process(data)\n\n    print score\n    print \" \".join(str(i) for i in testcase_status)", 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Which queue costs the least?", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 100, 
            "slug": "ticket", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Ticket", 
            "level": 96, 
            "success_ratio": 0.3473684210526316, 
            "total_count": 285, 
            "created_at": "2013-07-13T03:21:20.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": "python"
        }, 
        {
            "onboarding": null, 
            "solved_count": 27, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-05-30T08:24:37.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 15582, 
            "has_ended": false, 
            "is_custom": true, 
            "compile_and_test": true, 
            "checker_program": "/*\n * Copyright 2009-2010 Cybozu Labs, Inc.\n * Copyright 2011-2014 Kazuho Oku\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#ifndef picojson_h\n#define picojson_h\n\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstddef>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <stdexcept>\n#include <string>\n#include <vector>\n\n// for isnan/isinf\n#if __cplusplus>=201103L\n# include <cmath>\n#else\nextern \"C\" {\n# ifdef _MSC_VER\n#  include <float.h>\n# elif defined(__INTEL_COMPILER)\n#  include <mathimf.h>\n# else\n#  include <math.h>\n# endif\n}\n#endif\n\n#ifndef PICOJSON_USE_RVALUE_REFERENCE\n# if (defined(__cpp_rvalue_references) && __cpp_rvalue_references >= 200610) || (defined(_MSC_VER) && _MSC_VER >= 1600)\n#  define PICOJSON_USE_RVALUE_REFERENCE 1\n# else\n#  define PICOJSON_USE_RVALUE_REFERENCE 0\n# endif\n#endif//PICOJSON_USE_RVALUE_REFERENCE\n\n\n// experimental support for int64_t (see README.mkdn for detail)\n#ifdef PICOJSON_USE_INT64\n# define __STDC_FORMAT_MACROS\n# include <errno.h>\n# include <inttypes.h>\n#endif\n\n// to disable the use of localeconv(3), set PICOJSON_USE_LOCALE to 0\n#ifndef PICOJSON_USE_LOCALE\n# define PICOJSON_USE_LOCALE 1\n#endif\n#if PICOJSON_USE_LOCALE\nextern \"C\" {\n# include <locale.h>\n}\n#endif\n\n#ifndef PICOJSON_ASSERT\n# define PICOJSON_ASSERT(e) do { if (! (e)) throw std::runtime_error(#e); } while (0)\n#endif\n\n#ifdef _MSC_VER\n    #define SNPRINTF _snprintf_s\n    #pragma warning(push)\n    #pragma warning(disable : 4244) // conversion from int to char\n    #pragma warning(disable : 4127) // conditional expression is constant\n    #pragma warning(disable : 4702) // unreachable code\n#else\n    #define SNPRINTF snprintf\n#endif\n\nnamespace picojson {\n  \n  enum {\n    null_type,\n    boolean_type,\n    number_type,\n    string_type,\n    array_type,\n    object_type\n#ifdef PICOJSON_USE_INT64\n    , int64_type\n#endif\n  };\n  \n  enum {\n    INDENT_WIDTH = 2\n  };\n\n  struct null {};\n  \n  class value {\n  public:\n    typedef std::vector<value> array;\n    typedef std::map<std::string, value> object;\n    union _storage {\n      bool boolean_;\n      double number_;\n#ifdef PICOJSON_USE_INT64\n      int64_t int64_;\n#endif\n      std::string* string_;\n      array* array_;\n      object* object_;\n    };\n  protected:\n    int type_;\n    _storage u_;\n  public:\n    value();\n    value(int type, bool);\n    explicit value(bool b);\n#ifdef PICOJSON_USE_INT64\n    explicit value(int64_t i);\n#endif\n    explicit value(double n);\n    explicit value(const std::string& s);\n    explicit value(const array& a);\n    explicit value(const object& o);\n    explicit value(const char* s);\n    value(const char* s, size_t len);\n    ~value();\n    value(const value& x);\n    value& operator=(const value& x);\n#if PICOJSON_USE_RVALUE_REFERENCE \n    value(value&& x)throw();\n    value& operator=(value&& x)throw();\n#endif\n    void swap(value& x)throw();\n    template <typename T> bool is() const;\n    template <typename T> const T& get() const;\n    template <typename T> T& get();\n    bool evaluate_as_boolean() const;\n    const value& get(size_t idx) const;\n    const value& get(const std::string& key) const;\n    value& get(size_t idx);\n    value& get(const std::string& key);\n\n    bool contains(size_t idx) const;\n    bool contains(const std::string& key) const;\n    std::string to_str() const;\n    template <typename Iter> void serialize(Iter os, bool prettify = false) const;\n    std::string serialize(bool prettify = false) const;\n  private:\n    template <typename T> value(const T*); // intentionally defined to block implicit conversion of pointer to bool\n    template <typename Iter> static void _indent(Iter os, int indent);\n    template <typename Iter> void _serialize(Iter os, int indent) const;\n    std::string _serialize(int indent) const;\n  };\n  \n  typedef value::array array;\n  typedef value::object object;\n  \n  inline value::value() : type_(null_type) {}\n  \n  inline value::value(int type, bool) : type_(type) {\n    switch (type) {\n#define INIT(p, v) case p##type: u_.p = v; break\n      INIT(boolean_, false);\n      INIT(number_, 0.0);\n#ifdef PICOJSON_USE_INT64\n      INIT(int64_, 0);\n#endif\n      INIT(string_, new std::string());\n      INIT(array_, new array());\n      INIT(object_, new object());\n#undef INIT\n    default: break;\n    }\n  }\n  \n  inline value::value(bool b) : type_(boolean_type) {\n    u_.boolean_ = b;\n  }\n\n#ifdef PICOJSON_USE_INT64\n  inline value::value(int64_t i) : type_(int64_type) {\n    u_.int64_ = i;\n  }\n#endif\n\n  inline value::value(double n) : type_(number_type) {\n    if (\n#ifdef _MSC_VER\n        ! _finite(n)\n#elif __cplusplus>=201103L || !(defined(isnan) && defined(isinf))\n\t\tstd::isnan(n) || std::isinf(n)\n#else\n        isnan(n) || isinf(n)\n#endif\n        ) {\n      throw std::overflow_error(\"\");\n    }\n    u_.number_ = n;\n  }\n  \n  inline value::value(const std::string& s) : type_(string_type) {\n    u_.string_ = new std::string(s);\n  }\n  \n  inline value::value(const array& a) : type_(array_type) {\n    u_.array_ = new array(a);\n  }\n  \n  inline value::value(const object& o) : type_(object_type) {\n    u_.object_ = new object(o);\n  }\n  \n  inline value::value(const char* s) : type_(string_type) {\n    u_.string_ = new std::string(s);\n  }\n  \n  inline value::value(const char* s, size_t len) : type_(string_type) {\n    u_.string_ = new std::string(s, len);\n  }\n  \n  inline value::~value() {\n    switch (type_) {\n#define DEINIT(p) case p##type: delete u_.p; break\n      DEINIT(string_);\n      DEINIT(array_);\n      DEINIT(object_);\n#undef DEINIT\n    default: break;\n    }\n  }\n  \n  inline value::value(const value& x) : type_(x.type_) {\n    switch (type_) {\n#define INIT(p, v) case p##type: u_.p = v; break\n      INIT(string_, new std::string(*x.u_.string_));\n      INIT(array_, new array(*x.u_.array_));\n      INIT(object_, new object(*x.u_.object_));\n#undef INIT\n    default:\n      u_ = x.u_;\n      break;\n    }\n  }\n  \n  inline value& value::operator=(const value& x) {\n    if (this != &x) {\n      value t(x);\n      swap(t);\n    }\n    return *this;\n  }\n\n#if PICOJSON_USE_RVALUE_REFERENCE \n  inline value::value(value&& x)throw() : type_(null_type) {\n    swap(x);\n  }\n  inline value& value::operator=(value&& x)throw() {\n    swap(x);\n    return *this;\n  }\n#endif\n  inline void value::swap(value& x)throw() {\n    std::swap(type_, x.type_);\n    std::swap(u_, x.u_);\n  }\n  \n#define IS(ctype, jtype)\t\t\t     \\\n  template <> inline bool value::is<ctype>() const { \\\n    return type_ == jtype##_type;\t\t     \\\n  }\n  IS(null, null)\n  IS(bool, boolean)\n#ifdef PICOJSON_USE_INT64\n  IS(int64_t, int64)\n#endif\n  IS(std::string, string)\n  IS(array, array)\n  IS(object, object)\n#undef IS\n  template <> inline bool value::is<double>() const {\n    return type_ == number_type\n#ifdef PICOJSON_USE_INT64\n      || type_ == int64_type\n#endif\n      ;\n  }\n  \n#define GET(ctype, var)\t\t\t\t\t\t\\\n  template <> inline const ctype& value::get<ctype>() const {\t\\\n    PICOJSON_ASSERT(\"type mismatch! call is<type>() before get<type>()\" \\\n\t   && is<ctype>());\t\t\t\t        \\\n    return var;\t\t\t\t\t\t\t\\\n  }\t\t\t\t\t\t\t\t\\\n  template <> inline ctype& value::get<ctype>() {\t\t\\\n    PICOJSON_ASSERT(\"type mismatch! call is<type>() before get<type>()\"\t\\\n\t   && is<ctype>());\t\t\t\t\t\\\n    return var;\t\t\t\t\t\t\t\\\n  }\n  GET(bool, u_.boolean_)\n  GET(std::string, *u_.string_)\n  GET(array, *u_.array_)\n  GET(object, *u_.object_)\n#ifdef PICOJSON_USE_INT64\n  GET(double, (type_ == int64_type && (const_cast<value*>(this)->type_ = number_type, const_cast<value*>(this)->u_.number_ = u_.int64_), u_.number_))\n  GET(int64_t, u_.int64_)\n#else\n  GET(double, u_.number_)\n#endif\n#undef GET\n  \n  inline bool value::evaluate_as_boolean() const {\n    switch (type_) {\n    case null_type:\n      return false;\n    case boolean_type:\n      return u_.boolean_;\n    case number_type:\n      return u_.number_ != 0;\n#ifdef PICOJSON_USE_INT64\n    case int64_type:\n      return u_.int64_ != 0;\n#endif\n    case string_type:\n      return ! u_.string_->empty();\n    default:\n      return true;\n    }\n  }\n  \n  inline const value& value::get(size_t idx) const {\n    static value s_null;\n    PICOJSON_ASSERT(is<array>());\n    return idx < u_.array_->size() ? (*u_.array_)[idx] : s_null;\n  }\n\n  inline value& value::get(size_t idx) {\n    static value s_null;\n    PICOJSON_ASSERT(is<array>());\n    return idx < u_.array_->size() ? (*u_.array_)[idx] : s_null;\n  }\n\n  inline const value& value::get(const std::string& key) const {\n    static value s_null;\n    PICOJSON_ASSERT(is<object>());\n    object::const_iterator i = u_.object_->find(key);\n    return i != u_.object_->end() ? i->second : s_null;\n  }\n\n  inline value& value::get(const std::string& key) {\n    static value s_null;\n    PICOJSON_ASSERT(is<object>());\n    object::iterator i = u_.object_->find(key);\n    return i != u_.object_->end() ? i->second : s_null;\n  }\n\n  inline bool value::contains(size_t idx) const {\n    PICOJSON_ASSERT(is<array>());\n    return idx < u_.array_->size();\n  }\n\n  inline bool value::contains(const std::string& key) const {\n    PICOJSON_ASSERT(is<object>());\n    object::const_iterator i = u_.object_->find(key);\n    return i != u_.object_->end();\n  }\n  \n  inline std::string value::to_str() const {\n    switch (type_) {\n    case null_type:      return \"null\";\n    case boolean_type:   return u_.boolean_ ? \"true\" : \"false\";\n#ifdef PICOJSON_USE_INT64\n    case int64_type: {\n      char buf[sizeof(\"-9223372036854775808\")];\n      SNPRINTF(buf, sizeof(buf), \"%\" PRId64, u_.int64_);\n      return buf;\n    }\n#endif\n    case number_type:    {\n      char buf[256];\n      double tmp;\n      SNPRINTF(buf, sizeof(buf), fabs(u_.number_) < (1ULL << 53) && modf(u_.number_, &tmp) == 0 ? \"%.f\" : \"%.17g\", u_.number_);\n#if PICOJSON_USE_LOCALE\n      char *decimal_point = localeconv()->decimal_point;\n      if (strcmp(decimal_point, \".\") != 0) {\n        size_t decimal_point_len = strlen(decimal_point);\n        for (char *p = buf; *p != '\\0'; ++p) {\n          if (strncmp(p, decimal_point, decimal_point_len) == 0) {\n            return std::string(buf, p) + \".\" + (p + decimal_point_len);\n          }\n        }\n      }\n#endif\n      return buf;\n    }\n    case string_type:    return *u_.string_;\n    case array_type:     return \"array\";\n    case object_type:    return \"object\";\n    default:             PICOJSON_ASSERT(0);\n#ifdef _MSC_VER\n      __assume(0);\n#endif\n    }\n    return std::string();\n  }\n  \n  template <typename Iter> void copy(const std::string& s, Iter oi) {\n    std::copy(s.begin(), s.end(), oi);\n  }\n  \n  template <typename Iter> void serialize_str(const std::string& s, Iter oi) {\n    *oi++ = '\"';\n    for (std::string::const_iterator i = s.begin(); i != s.end(); ++i) {\n      switch (*i) {\n#define MAP(val, sym) case val: copy(sym, oi); break\n\tMAP('\"', \"\\\\\\\"\");\n\tMAP('\\\\', \"\\\\\\\\\");\n\tMAP('/', \"\\\\/\");\n\tMAP('\\b', \"\\\\b\");\n\tMAP('\\f', \"\\\\f\");\n\tMAP('\\n', \"\\\\n\");\n\tMAP('\\r', \"\\\\r\");\n\tMAP('\\t', \"\\\\t\");\n#undef MAP\n      default:\n\tif (static_cast<unsigned char>(*i) < 0x20 || *i == 0x7f) {\n\t  char buf[7];\n\t  SNPRINTF(buf, sizeof(buf), \"\\\\u%04x\", *i & 0xff);\n\t  copy(buf, buf + 6, oi);\n\t  } else {\n\t  *oi++ = *i;\n\t}\n\tbreak;\n      }\n    }\n    *oi++ = '\"';\n  }\n\n  template <typename Iter> void value::serialize(Iter oi, bool prettify) const {\n    return _serialize(oi, prettify ? 0 : -1);\n  }\n  \n  inline std::string value::serialize(bool prettify) const {\n    return _serialize(prettify ? 0 : -1);\n  }\n\n  template <typename Iter> void value::_indent(Iter oi, int indent) {\n    *oi++ = '\\n';\n    for (int i = 0; i < indent * INDENT_WIDTH; ++i) {\n      *oi++ = ' ';\n    }\n  }\n\n  template <typename Iter> void value::_serialize(Iter oi, int indent) const {\n    switch (type_) {\n    case string_type:\n      serialize_str(*u_.string_, oi);\n      break;\n    case array_type: {\n      *oi++ = '[';\n      if (indent != -1) {\n        ++indent;\n      }\n      for (array::const_iterator i = u_.array_->begin();\n           i != u_.array_->end();\n           ++i) {\n\tif (i != u_.array_->begin()) {\n\t  *oi++ = ',';\n\t}\n        if (indent != -1) {\n          _indent(oi, indent);\n        }\n\ti->_serialize(oi, indent);\n      }\n      if (indent != -1) {\n        --indent;\n        if (! u_.array_->empty()) {\n          _indent(oi, indent);\n        }\n      }\n      *oi++ = ']';\n      break;\n    }\n    case object_type: {\n      *oi++ = '{';\n      if (indent != -1) {\n        ++indent;\n      }\n      for (object::const_iterator i = u_.object_->begin();\n\t   i != u_.object_->end();\n\t   ++i) {\n\tif (i != u_.object_->begin()) {\n\t  *oi++ = ',';\n\t}\n        if (indent != -1) {\n          _indent(oi, indent);\n        }\n\tserialize_str(i->first, oi);\n\t*oi++ = ':';\n        if (indent != -1) {\n          *oi++ = ' ';\n        }\n        i->second._serialize(oi, indent);\n      }\n      if (indent != -1) {\n        --indent;\n        if (! u_.object_->empty()) {\n          _indent(oi, indent);\n        }\n      }\n      *oi++ = '}';\n      break;\n    }\n    default:\n      copy(to_str(), oi);\n      break;\n    }\n    if (indent == 0) {\n      *oi++ = '\\n';\n    }\n  }\n  \n  inline std::string value::_serialize(int indent) const {\n    std::string s;\n    _serialize(std::back_inserter(s), indent);\n    return s;\n  }\n  \n  template <typename Iter> class input {\n  protected:\n    Iter cur_, end_;\n    int last_ch_;\n    bool ungot_;\n    int line_;\n  public:\n    input(const Iter& first, const Iter& last) : cur_(first), end_(last), last_ch_(-1), ungot_(false), line_(1) {}\n    int getc() {\n      if (ungot_) {\n\tungot_ = false;\n\treturn last_ch_;\n      }\n      if (cur_ == end_) {\n\tlast_ch_ = -1;\n\treturn -1;\n      }\n      if (last_ch_ == '\\n') {\n\tline_++;\n      }\n      last_ch_ = *cur_ & 0xff;\n      ++cur_;\n      return last_ch_;\n    }\n    void ungetc() {\n      if (last_ch_ != -1) {\n\tPICOJSON_ASSERT(! ungot_);\n\tungot_ = true;\n      }\n    }\n    Iter cur() const { return cur_; }\n    int line() const { return line_; }\n    void skip_ws() {\n      while (1) {\n\tint ch = getc();\n\tif (! (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r')) {\n\t  ungetc();\n\t  break;\n\t}\n      }\n    }\n    bool expect(int expect) {\n      skip_ws();\n      if (getc() != expect) {\n\tungetc();\n\treturn false;\n      }\n      return true;\n    }\n    bool match(const std::string& pattern) {\n      for (std::string::const_iterator pi(pattern.begin());\n\t   pi != pattern.end();\n\t   ++pi) {\n\tif (getc() != *pi) {\n\t  ungetc();\n\t  return false;\n\t}\n      }\n      return true;\n    }\n  };\n  \n  template<typename Iter> inline int _parse_quadhex(input<Iter> &in) {\n    int uni_ch = 0, hex;\n    for (int i = 0; i < 4; i++) {\n      if ((hex = in.getc()) == -1) {\n\treturn -1;\n      }\n      if ('0' <= hex && hex <= '9') {\n\thex -= '0';\n      } else if ('A' <= hex && hex <= 'F') {\n\thex -= 'A' - 0xa;\n      } else if ('a' <= hex && hex <= 'f') {\n\thex -= 'a' - 0xa;\n      } else {\n\tin.ungetc();\n\treturn -1;\n      }\n      uni_ch = uni_ch * 16 + hex;\n    }\n    return uni_ch;\n  }\n  \n  template<typename String, typename Iter> inline bool _parse_codepoint(String& out, input<Iter>& in) {\n    int uni_ch;\n    if ((uni_ch = _parse_quadhex(in)) == -1) {\n      return false;\n    }\n    if (0xd800 <= uni_ch && uni_ch <= 0xdfff) {\n      if (0xdc00 <= uni_ch) {\n\t// a second 16-bit of a surrogate pair appeared\n\treturn false;\n      }\n      // first 16-bit of surrogate pair, get the next one\n      if (in.getc() != '\\\\' || in.getc() != 'u') {\n\tin.ungetc();\n\treturn false;\n      }\n      int second = _parse_quadhex(in);\n      if (! (0xdc00 <= second && second <= 0xdfff)) {\n\treturn false;\n      }\n      uni_ch = ((uni_ch - 0xd800) << 10) | ((second - 0xdc00) & 0x3ff);\n      uni_ch += 0x10000;\n    }\n    if (uni_ch < 0x80) {\n      out.push_back(uni_ch);\n    } else {\n      if (uni_ch < 0x800) {\n\tout.push_back(0xc0 | (uni_ch >> 6));\n      } else {\n\tif (uni_ch < 0x10000) {\n\t  out.push_back(0xe0 | (uni_ch >> 12));\n\t} else {\n\t  out.push_back(0xf0 | (uni_ch >> 18));\n\t  out.push_back(0x80 | ((uni_ch >> 12) & 0x3f));\n\t}\n\tout.push_back(0x80 | ((uni_ch >> 6) & 0x3f));\n      }\n      out.push_back(0x80 | (uni_ch & 0x3f));\n    }\n    return true;\n  }\n  \n  template<typename String, typename Iter> inline bool _parse_string(String& out, input<Iter>& in) {\n    while (1) {\n      int ch = in.getc();\n      if (ch < ' ') {\n\tin.ungetc();\n\treturn false;\n      } else if (ch == '\"') {\n\treturn true;\n      } else if (ch == '\\\\') {\n\tif ((ch = in.getc()) == -1) {\n\t  return false;\n\t}\n\tswitch (ch) {\n#define MAP(sym, val) case sym: out.push_back(val); break\n\t  MAP('\"', '\\\"');\n\t  MAP('\\\\', '\\\\');\n\t  MAP('/', '/');\n\t  MAP('b', '\\b');\n\t  MAP('f', '\\f');\n\t  MAP('n', '\\n');\n\t  MAP('r', '\\r');\n\t  MAP('t', '\\t');\n#undef MAP\n\tcase 'u':\n\t  if (! _parse_codepoint(out, in)) {\n\t    return false;\n\t  }\n\t  break;\n\tdefault:\n\t  return false;\n\t}\n      } else {\n\tout.push_back(ch);\n      }\n    }\n    return false;\n  }\n  \n  template <typename Context, typename Iter> inline bool _parse_array(Context& ctx, input<Iter>& in) {\n    if (! ctx.parse_array_start()) {\n      return false;\n    }\n    size_t idx = 0;\n    if (in.expect(']')) {\n      return ctx.parse_array_stop(idx);\n    }\n    do {\n      if (! ctx.parse_array_item(in, idx)) {\n\treturn false;\n      }\n      idx++;\n    } while (in.expect(','));\n    return in.expect(']') && ctx.parse_array_stop(idx);\n  }\n  \n  template <typename Context, typename Iter> inline bool _parse_object(Context& ctx, input<Iter>& in) {\n    if (! ctx.parse_object_start()) {\n      return false;\n    }\n    if (in.expect('}')) {\n      return true;\n    }\n    do {\n      std::string key;\n      if (! in.expect('\"')\n\t  || ! _parse_string(key, in)\n\t  || ! in.expect(':')) {\n\treturn false;\n      }\n      if (! ctx.parse_object_item(in, key)) {\n\treturn false;\n      }\n    } while (in.expect(','));\n    return in.expect('}');\n  }\n  \n  template <typename Iter> inline std::string _parse_number(input<Iter>& in) {\n    std::string num_str;\n    while (1) {\n      int ch = in.getc();\n      if (('0' <= ch && ch <= '9') || ch == '+' || ch == '-'\n          || ch == 'e' || ch == 'E') {\n        num_str.push_back(ch);\n      } else if (ch == '.') {\n#if PICOJSON_USE_LOCALE\n        num_str += localeconv()->decimal_point;\n#else\n        num_str.push_back('.');\n#endif\n      } else {\n\tin.ungetc();\n\tbreak;\n      }\n    }\n    return num_str;\n  }\n  \n  template <typename Context, typename Iter> inline bool _parse(Context& ctx, input<Iter>& in) {\n    in.skip_ws();\n    int ch = in.getc();\n    switch (ch) {\n#define IS(ch, text, op) case ch: \\\n      if (in.match(text) && op) { \\\n\treturn true; \\\n      } else { \\\n\treturn false; \\\n      }\n      IS('n', \"ull\", ctx.set_null());\n      IS('f', \"alse\", ctx.set_bool(false));\n      IS('t', \"rue\", ctx.set_bool(true));\n#undef IS\n    case '\"':\n      return ctx.parse_string(in);\n    case '[':\n      return _parse_array(ctx, in);\n    case '{':\n      return _parse_object(ctx, in);\n    default:\n      if (('0' <= ch && ch <= '9') || ch == '-') {\n        double f;\n        char *endp;\n\tin.ungetc();\n        std::string num_str = _parse_number(in);\n        if (num_str.empty()) {\n          return false;\n        }\n#ifdef PICOJSON_USE_INT64\n        {\n          errno = 0;\n          intmax_t ival = strtoimax(num_str.c_str(), &endp, 10);\n          if (errno == 0\n              && std::numeric_limits<int64_t>::min() <= ival\n              && ival <= std::numeric_limits<int64_t>::max()\n              && endp == num_str.c_str() + num_str.size()) {\n            ctx.set_int64(ival);\n            return true;\n          }\n        }\n#endif\n        f = strtod(num_str.c_str(), &endp);\n        if (endp == num_str.c_str() + num_str.size()) {\n          ctx.set_number(f);\n          return true;\n        }\n        return false;\n      }\n      break;\n    }\n    in.ungetc();\n    return false;\n  }\n  \n  class deny_parse_context {\n  public:\n    bool set_null() { return false; }\n    bool set_bool(bool) { return false; }\n#ifdef PICOJSON_USE_INT64\n    bool set_int64(int64_t) { return false; }\n#endif\n    bool set_number(double) { return false; }\n    template <typename Iter> bool parse_string(input<Iter>&) { return false; }\n    bool parse_array_start() { return false; }\n    template <typename Iter> bool parse_array_item(input<Iter>&, size_t) {\n      return false;\n    }\n    bool parse_array_stop(size_t) { return false; }\n    bool parse_object_start() { return false; }\n    template <typename Iter> bool parse_object_item(input<Iter>&, const std::string&) {\n      return false;\n    }\n  };\n  \n  class default_parse_context {\n  protected:\n    value* out_;\n  public:\n    default_parse_context(value* out) : out_(out) {}\n    bool set_null() {\n      *out_ = value();\n      return true;\n    }\n    bool set_bool(bool b) {\n      *out_ = value(b);\n      return true;\n    }\n#ifdef PICOJSON_USE_INT64\n    bool set_int64(int64_t i) {\n      *out_ = value(i);\n      return true;\n    }\n#endif\n    bool set_number(double f) {\n      *out_ = value(f);\n      return true;\n    }\n    template<typename Iter> bool parse_string(input<Iter>& in) {\n      *out_ = value(string_type, false);\n      return _parse_string(out_->get<std::string>(), in);\n    }\n    bool parse_array_start() {\n      *out_ = value(array_type, false);\n      return true;\n    }\n    template <typename Iter> bool parse_array_item(input<Iter>& in, size_t) {\n      array& a = out_->get<array>();\n      a.push_back(value());\n      default_parse_context ctx(&a.back());\n      return _parse(ctx, in);\n    }\n    bool parse_array_stop(size_t) { return true; }\n    bool parse_object_start() {\n      *out_ = value(object_type, false);\n      return true;\n    }\n    template <typename Iter> bool parse_object_item(input<Iter>& in, const std::string& key) {\n      object& o = out_->get<object>();\n      default_parse_context ctx(&o[key]);\n      return _parse(ctx, in);\n    }\n  private:\n    default_parse_context(const default_parse_context&);\n    default_parse_context& operator=(const default_parse_context&);\n  };\n\n  class null_parse_context {\n  public:\n    struct dummy_str {\n      void push_back(int) {}\n    };\n  public:\n    null_parse_context() {}\n    bool set_null() { return true; }\n    bool set_bool(bool) { return true; }\n#ifdef PICOJSON_USE_INT64\n    bool set_int64(int64_t) { return true; }\n#endif\n    bool set_number(double) { return true; }\n    template <typename Iter> bool parse_string(input<Iter>& in) {\n      dummy_str s;\n      return _parse_string(s, in);\n    }\n    bool parse_array_start() { return true; }\n    template <typename Iter> bool parse_array_item(input<Iter>& in, size_t) {\n      return _parse(*this, in);\n    }\n    bool parse_array_stop(size_t) { return true; }\n    bool parse_object_start() { return true; }\n    template <typename Iter> bool parse_object_item(input<Iter>& in, const std::string&) {\n      return _parse(*this, in);\n    }\n  private:\n    null_parse_context(const null_parse_context&);\n    null_parse_context& operator=(const null_parse_context&);\n  };\n  \n  // obsolete, use the version below\n  template <typename Iter> inline std::string parse(value& out, Iter& pos, const Iter& last) {\n    std::string err;\n    pos = parse(out, pos, last, &err);\n    return err;\n  }\n  \n  template <typename Context, typename Iter> inline Iter _parse(Context& ctx, const Iter& first, const Iter& last, std::string* err) {\n    input<Iter> in(first, last);\n    if (! _parse(ctx, in) && err != NULL) {\n      char buf[64];\n      SNPRINTF(buf, sizeof(buf), \"syntax error at line %d near: \", in.line());\n      *err = buf;\n      while (1) {\n\tint ch = in.getc();\n\tif (ch == -1 || ch == '\\n') {\n\t  break;\n\t} else if (ch >= ' ') {\n\t  err->push_back(ch);\n\t}\n      }\n    }\n    return in.cur();\n  }\n  \n  template <typename Iter> inline Iter parse(value& out, const Iter& first, const Iter& last, std::string* err) {\n    default_parse_context ctx(&out);\n    return _parse(ctx, first, last, err);\n  }\n  \n  inline std::string parse(value& out, const std::string& s) {\n    std::string err;\n    parse(out, s.begin(), s.end(), &err);\n    return err;\n  }\n\n  inline std::string parse(value& out, std::istream& is) {\n    std::string err;\n    parse(out, std::istreambuf_iterator<char>(is.rdbuf()),\n\t  std::istreambuf_iterator<char>(), &err);\n    return err;\n  }\n  \n  template <typename T> struct last_error_t {\n    static std::string s;\n  };\n  template <typename T> std::string last_error_t<T>::s;\n  \n  inline void set_last_error(const std::string& s) {\n    last_error_t<bool>::s = s;\n  }\n  \n  inline const std::string& get_last_error() {\n    return last_error_t<bool>::s;\n  }\n\n  inline bool operator==(const value& x, const value& y) {\n    if (x.is<null>())\n      return y.is<null>();\n#define PICOJSON_CMP(type)\t\t\t\t\t\\\n    if (x.is<type>())\t\t\t\t\t\t\\\n      return y.is<type>() && x.get<type>() == y.get<type>()\n    PICOJSON_CMP(bool);\n    PICOJSON_CMP(double);\n    PICOJSON_CMP(std::string);\n    PICOJSON_CMP(array);\n    PICOJSON_CMP(object);\n#undef PICOJSON_CMP\n    PICOJSON_ASSERT(0);\n#ifdef _MSC_VER\n    __assume(0);\n#endif\n    return false;\n  }\n  \n  inline bool operator!=(const value& x, const value& y) {\n    return ! (x == y);\n  }\n}\n\n#if !PICOJSON_USE_RVALUE_REFERENCE \nnamespace std {\n  template<> inline void swap(picojson::value& x, picojson::value& y)\n    {\n      x.swap(y);\n    }\n}\n#endif\n\ninline std::istream& operator>>(std::istream& is, picojson::value& x)\n{\n  picojson::set_last_error(std::string());\n  std::string err = picojson::parse(x, is);\n  if (! err.empty()) {\n    picojson::set_last_error(err);\n    is.setstate(std::ios::failbit);\n  }\n  return is;\n}\n\ninline std::ostream& operator<<(std::ostream& os, const picojson::value& x)\n{\n  x.serialize(std::ostream_iterator<char>(os));\n  return os;\n}\n#ifdef _MSC_VER\n    #pragma warning(pop)\n#endif\n\n#endif\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define forab(i,a,b) for (int i = int(a); i < int(b); ++i)\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 1000001000;\nconst ll INFL = 2000000000000001000;\n\n#define OK_EXIT_CODE 1\n#define WA_EXIT_CODE 0\n#define PE_EXIT_CODE 0\n\n\nconst int maxn = 2e5;\nvector<int> g[maxn];\n\nint treeCnt, backCnt, forwardCnt, crossCnt;\n\nint in[maxn];\nint used[maxn];\nint timer;\n\nvoid dfs(int u)\n{\n    used[u] = 1;\n    in[u] = timer++;\n    for (int v: g[u])\n    {\n        assert(v != u);\n        if (used[v] == 2)\n        {\n            if (in[u] <= in[v])\n                forwardCnt++;\n            else\n                crossCnt++;\n            continue;\n        }\n        if (used[v] == 1)\n        {\n            backCnt++;\n            continue;\n        }\n        treeCnt++;\n        dfs(v);\n    }\n    used[u] = 2;\n}\n\nint check(int argc, const char **argv)\n{\n    assert(argc > 3);\n    FILE *in = fopen(argv[1], \"r\");\n    FILE *out = fopen(argv[2], \"r\");\n//    FILE *ans = fopen(argv[3], \"r\");\n    const char *ans = argv[3];\n    int tree, back, forward, cross;\n    assert(fscanf(in, \"%d%d%d%d\", &tree, &back, &forward, &cross) == 4);\n    fclose(in);\n    int N, n;\n    assert(sscanf(ans, \"%d\", &N) == 1);\n//    fclose(ans);\n    if (fscanf(out, \"%d\", &n) != 1)\n        return PE_EXIT_CODE;\n    if (n != N)\n        return WA_EXIT_CODE;\n    if (n == -1)\n        return OK_EXIT_CODE;\n    forn (u, n)\n    {\n        g[u].clear();\n        ::in[u] = -1;\n        used[u] = 0;\n\n        int deg;\n        if (fscanf(out, \"%d\", &deg) != 1)\n            return PE_EXIT_CODE;\n        if (deg < 0 || deg >= n)\n            return PE_EXIT_CODE;\n        vector<int> sorted;\n        forn (j, deg)\n        {\n            int v;\n            if (fscanf(out, \"%d\", &v) != 1)\n                return PE_EXIT_CODE;\n            --v;\n            if (v < 0 || v >= n || v == u)\n                return PE_EXIT_CODE;\n            g[u].push_back(v);\n            sorted.push_back(v);\n        }\n        sort(sorted.begin(), sorted.end());\n        forn (i, sz(sorted) - 1)\n            if (sorted[i] == sorted[i + 1])\n                return PE_EXIT_CODE;\n    }\n    fclose(out);\n    treeCnt = backCnt = forwardCnt = crossCnt = 0;\n    timer = 0;\n    dfs(0);\n    if (treeCnt != tree || backCnt != back || forwardCnt != forward || crossCnt != cross)\n        return WA_EXIT_CODE;\n    return OK_EXIT_CODE;\n}\n\nint main()\n{\n    string directory, line;\n    while (getline(cin, line))\n        directory = line;\n    string request = directory + \"request.json\";\n    assert(freopen(request.c_str(), \"r\", stdin));\n    picojson::value rawJSON;\n//    Json::Value json;\n    cin >> rawJSON;\n    assert(rawJSON.is<picojson::object>());\n    picojson::object json = rawJSON.get<picojson::object>();\n//    int tests = json[\"testcase_sources\"].size();\n    assert(json[\"testcase_sources\"].is<picojson::array>());\n    int tests = json[\"testcase_sources\"].get<picojson::array>().size();\n\n    vector<int> res;\n    char in[1000], out[1000];\n    forn (i, tests)\n    {\n        sprintf(in, \"%sinput%05d.in\", directory.c_str(), i);\n        sprintf(out, \"%soutput%05d.out\", directory.c_str(), i);\n//        const char *ans = json[\"expected_outputs\"][i].asCString();\n        string ans = json[\"expected_outputs\"].get<picojson::array>()[i].get<string>();\n        const char *fictiveArgv[4] = {NULL, in, out, ans.c_str()};\n        res.push_back(check(4, fictiveArgv));\n    }\n    double score = (double)accumulate(res.begin(), res.end(), 0) / (double)tests;\n    cout << score << '\\n';\n    forn (i, sz(res))\n        cout << res[i] << \" \\n\"[i + 1 == sz(res)];\n}\n", 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Find a graph with given number of tree, back, forward, and cross edges. ", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 100, 
            "slug": "dfs-edges", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "DFS Edges", 
            "level": 50, 
            "success_ratio": 0.7297297297297297, 
            "total_count": 37, 
            "created_at": "2015-12-27T21:57:11.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": "cpp"
        }, 
        {
            "onboarding": null, 
            "solved_count": 27, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-05-30T08:26:29.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 29999, 
            "has_ended": false, 
            "is_custom": true, 
            "compile_and_test": true, 
            "checker_program": "from __future__ import division\nimport json\nfrom math import sqrt\nfrom sys import stdin\n\nimport sys\n\n\ndef bfs(u, g):\n    n = len(g)\n    m = len(g[0])\n\n    dist = [n for i in range(n)]\n    dist[u] = 0\n    q = [u]\n    ptr = 0\n\n    while ptr < len(q):\n        u = q[ptr]\n        ptr += 1\n        for i in range(m):\n            v = g[u][i]\n            if dist[v] < n:\n                continue\n            dist[v] = dist[u] + 1\n            q.append(v)\n\n    if len(q) != n:\n        return 100 * n\n    else:\n        return dist[q[-1]]\n\n\ndef get_score(inf, ouf, ans):\n    try:\n        n, m = inf.split(' ')\n        n = int(n)\n        m = int(m)\n        d = int(ans.split('\\n')[0])\n\n        lines = ouf.split('\\n')\n        f = int(lines[0])\n\n        g = []\n        for i in range(n):\n            out = list(map(int, lines[i + 1].split()))\n            assert len(out) == m\n            g.append(out)\n\n        diam = 0\n        for i in range(n):\n            diam = max(diam, bfs(i, g))\n\n        assert(diam == f)\n\n        if f <= d + 1:\n            return 1\n        elif f <= 5 * d:\n            return float(d) / float(f)\n        else:\n            return 0\n        \n    except:\n        # raise\n        return 0\n\ndef check_inputs (inputs, outputs, user_outputs):\n    #inputs is a \"python list\" of all input files. Inputs contains the contents of each of these files.\n\n    is_code_works = True\n    '''\n    This is the boolean flag to check if the code works or not.\n    If you want to give a complete 0 score and give a wrong answer, set this flag to False\n    '''\n\n    scores = [ 0 for i in range( len( inputs ) ) ]\n    '''\n    This is an array of scores for each test case\n    Each element in the array should be between 0 and 1\n    We initially fill this array with 0\n    '''\n\n    testcase_status = [ 0 for i in range( len( inputs ) ) ]\n    '''\n    This is an array of status for each test case.\n    Each element in the array can be either 0 or 1\n    We initially fill this array with 0\n    '''\n\n    loop_counter = 0\n    for input_tc, output_tc, useroutput_tc in zip(inputs, outputs, user_outputs):\n        '''\n        input_tc, output_tc and useroutput_tc is the content of 1 complete file.\n        Remember to split on \"\\n\". Default split is a common mistake. Remember to trim the lines.\n        Custom checker should NEVER throw an error\n        Run it in try: except: blocks and verify input to avoid infinite time errors\n        Your code will read input_tc, output_tc and useroutput_tc\n        Your code will update is_code_works, scores[loop_counter], testcase_status[loop_counter]\n        '''\n\n        #YOUR CUSTOM CODE STARTS HERE\n        sc = get_score(input_tc, useroutput_tc, output_tc)\n        scores[loop_counter] = sc\n        if sc > 0:\n            testcase_status[loop_counter] = 1\n        #YOUR CUSTOM CODE ENDS HERE\n\n        loop_counter += 1\n    return is_code_works, scores, testcase_status\n\ndef process(data):\n    score = 0\n    testcase_input  = data[\"inputs\"]\n    testcase_output = data[\"expected_outputs\"]\n    user_output     = data[\"outputs\"]\n    is_code_works, scores, testcase_statuses = check_inputs(testcase_input, testcase_output, user_output)\n    score = sum(scores) * 1.0 / len(testcase_statuses)\n    return score, testcase_statuses\n\nif __name__ ==  '__main__':\n    stdin = stdin.read().split('\\n')\n\n    # Get the run directory for the submission we need to evaluate.\n    run_directory = stdin[-1]\n\n    # request.json contains the data submitted for the current.\n    request = json.load(open(run_directory + \"request.json\"))\n\n    data = {\n        # The submitted source code\n        \"source\": request[\"source\"],\n        # The list of test cases\n        \"testcases\": request[\"testcase_sources\"],\n        # The submitted language key (Eg: 5 for python)\n        \"lang\": request[\"lang\"],\n        # I'll tell you how to fill this next\n        \"expected_outputs\": request[\"expected_outputs\"],\n        \"inputs\": [],\n        \"outputs\": []\n    }\n\n    for index in range(len(request[\"testcase_sources\"])):\n        #Let's read the input00000.in files.\n        inputs = open(run_directory + \"input%05d.in\" %(index)).read()\n        data[\"inputs\"].append(inputs)\n\n        #Let's read the output00000.out files.\n        output = open(run_directory + \"output%05d.out\" %(index)).read()\n        data[\"outputs\"].append(output)\n\n    # Gathered all the data we could, lets process it\n    score, testcase_status = process(data)\n\n    #Let me explain what you should even print as output of customer checker.\n    #Line 1 should be the total score for the submission\n    #Line 2 should be a list of space separated integers (0/1), which denotes testcase status of each testcase\n    #Line 3 should be a list of space separated floats, which denotes testcase score of each testcase.\n    print score\n    print \" \".join(str(i) for i in testcase_status)\n", 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Given a number of nodes and a specific outdegree for all nodes, build a strongly-connected oriented graph with a minimal diameter.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 100, 
            "slug": "diameter-minimization", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Diameter Minimization", 
            "level": 50, 
            "success_ratio": 0.574468085106383, 
            "total_count": 47, 
            "created_at": "2016-12-19T21:36:11.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": "python"
        }, 
        {
            "onboarding": null, 
            "solved_count": 17, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:53:52.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 25134, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 100, 
            "is_solution_unlocked": false, 
            "preview": "Find the probability of each vertex in a graph being the last vertex visited.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Graph Theory", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 33, 
                "rewards_system_enabled": true, 
                "slug": "graph-theory"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 100, 
            "slug": "definite-random-walks", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Definite Random Walks", 
            "level": 100, 
            "success_ratio": 0.68, 
            "total_count": 25, 
            "created_at": "2016-09-16T21:06:10.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }
    ], 
    "tutorial_signed_up": true, 
    "current_track": {
        "name": "Algorithms", 
        "id": 3, 
        "priority": 14, 
        "descriptions": "The true test of problem solving: when one realizes that time and memory aren't infinite.\n", 
        "rewards_system_enabled": true, 
        "slug": "algorithms"
    }, 
    "total": 62
}