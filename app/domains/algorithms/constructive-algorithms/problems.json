{
    "models": [
        {
            "onboarding": null, 
            "solved_count": 54, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-05-30T08:27:55.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 30599, 
            "has_ended": false, 
            "is_custom": true, 
            "compile_and_test": true, 
            "checker_program": "{\"custom_checker_head\":\"\\n// Start of HEAD\\n#include <map>\\n#include <cmath>\\n#include <cstdio>\\n#include <vector>\\n#include <fstream>\\n#include <iostream>\\n#include <algorithm>\\n#ifdef __APPLE__\\n    #include <json/json.h>\\n#else\\n    #include <json/json.h>\\n#endif\\n\\nusing namespace std;\\nusing namespace Json;\\n\\nclass TestStruct {\\npublic:\\n    size_t testcase_id;\\n    string testcase_input_path;\\n    string testcase_output_path;\\n    string testcase_expected_output_path;\\n    vector<string> metadata_file_paths;\\n    string submission_code_path;\\n    bool testcase_result;\\n    size_t testcase_signal;\\n    float testcase_time;\\n    size_t testcase_memory;\\n    string data;\\n};\\n\\nclass ResultStruct {\\npublic:\\n    bool   result;\\n    float  score;\\n    string message;\\n};\\n// End of HEAD\\n        \",\"custom_checker_body\":\"\\n// Start of BODY\\n/**\\n * TestStruct members::\\n *  testcase_id                   [size_t] ID of the test-case\\n *  testcase_input_path           [string] File path to test-case input\\n *  testcase_output_path          [string] File path to test-case output generated by the problem solver\\n *  testcase_expected_output_path [string] File path to test-case expected output to be matched with\\n *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)\\n *  submission_code_path          [string] File path to submission source code\\n *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line\\n *  testcase_signal               [size_t] Exit code of the test-case process\\n *  testcase_time                 [float] Time taken by the test-case process in seconds\\n *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes\\n *  data                          [string] <Future use>\\n *\\n *\\n *  ResultStruct::\\n *    result      [bool]  Assign test-case result. true determines success. false determines failure\\n *    score       [float] Assign test-case score. Normalized between 0 to 1\\n *    message     [string] Assign test-case message. This message is visible to the problem solver\\n**/\\n#include <set>\\n#include <cassert>\\n#include <string>\\n#include <sstream>\\n\\nlong long int fast_lukas(vector <long long int> &A)\\n{\\n\\tint INF = 1000000009;\\n\\tmap <int,int> M;\\n\\tM[-INF] = 0;\\n\\tM[INF] = 0;\\n\\tlong long int ans = 0;\\n\\tfor (int i = 0; i < A.size(); ++i)\\n\\t{\\n\\t\\tmap <int,int>::iterator it = M.lower_bound(A[i]);\\n\\t\\t--it;\\n\\t\\tint val = it->first, dep = it->second;\\n\\t\\tans+=dep;\\n\\t\\tdep++;\\n\\t\\tM[val] = dep;\\n\\t\\tM[A[i]] = dep;\\n\\t}\\n\\treturn ans;\\n}\\nbool all_distinct(vector <long long int> &A)\\n{\\n\\tset <long long int> S;\\n\\tfor (int i = 0; i < A.size(); ++i)\\n\\t{\\n\\t\\tS.insert(A[i]);\\n\\t}\\n\\treturn (A.size() == S.size());\\n}\\nbool all_valid(vector <long long int> &A)\\n{\\n\\tbool ans = true;\\n\\tfor (int i = 0; i < A.size(); ++i)\\n\\t{\\n\\t\\tif(A[i] < 1 || A[i] > 1000000000)\\n\\t\\t\\tans = false;\\n\\t}\\n\\treturn ans;\\n}\\nbool check_output(const char input_path[], const char output_path[], const char correct_path[])\\n{\\n\\tifstream cin1(input_path);\\n\\tifstream cin2(output_path);\\n\\tifstream cin3(correct_path);\\n\\tint test_cases;\\n\\tbool ans = true;\\n\\tcin1>>test_cases;\\n\\twhile(test_cases--)\\n\\t{\\n\\t\\tint n,c;\\n\\t\\tcin1>>n>>c;\\n\\t\\tvector <long long int> user_op(n), exp_op(n);\\n\\t\\tcin2>>user_op[0];\\n\\t\\tcin3>>exp_op[0];\\n\\t\\tif(user_op[0] == -1 || exp_op[0] == -1)\\n\\t\\t{\\n\\t\\t\\tif(user_op[0] != exp_op[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tcin2>>user_op[i];\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tcin3>>exp_op[i];\\n\\t\\t}\\n\\t\\tassert(all_valid(exp_op) && all_distinct(exp_op) && fast_lukas(exp_op) == c);\\n\\t\\tif(!all_valid(user_op) || !all_distinct(user_op) || fast_lukas(user_op) != c)\\n\\t\\t{\\n\\t\\t\\tans = false;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n\\nvoid run_custom_checker(const TestStruct t_obj,\\n                        ResultStruct &r_obj) {\\n    //Don't print anything to STDOUT in this function\\n    //Enter your custom checker scoring logic here\\n\\n    r_obj.message = \\\"Success\\\";\\n    r_obj.result = check_output(t_obj.testcase_input_path.c_str(), t_obj.testcase_output_path.c_str(), t_obj.testcase_expected_output_path.c_str());\\n    if(!r_obj.result) {\\n        r_obj.message = \\\"Wrong Answer\\\\n\\\";\\n    }\\n    if (t_obj.testcase_signal != 0) {\\n        stringstream ss;\\n        ss << t_obj.testcase_signal;\\n        r_obj.message = \\\"Code terminated with signal \\\" + ss.str();\\n        r_obj.result = false;\\n    }\\n    if(r_obj.result)\\n        r_obj.score = 1.0f;\\n    else\\n        r_obj.score = 0.0f;\\n    \\n}\\n// End of BODY\\n        \",\"custom_checker_tail\":\"\\n// Start of TAIL\\nint read_input_json(const string json_file_path,\\n                    TestStruct &t_obj) {\\n    ifstream stream(json_file_path);\\n    string json_file_contents((std::istreambuf_iterator<char>(stream)),\\n                 std::istreambuf_iterator<char>());\\n\\n    Value root;\\n    Reader reader;\\n    if(!reader.parse(json_file_contents, root, false))\\n        return 1;\\n\\n    try {\\n        // Read values\\n        if(root.isMember(\\\"testcase_id\\\"))\\n            t_obj.testcase_id = root[\\\"testcase_id\\\"].asInt();\\n        if(root.isMember(\\\"input_file_path\\\"))\\n            t_obj.testcase_input_path = root[\\\"input_file_path\\\"].asString();\\n        if(root.isMember(\\\"output_file_path\\\"))\\n            t_obj.testcase_output_path = root[\\\"output_file_path\\\"].asString();\\n        if(root.isMember(\\\"expected_output_file_path\\\"))\\n            t_obj.testcase_expected_output_path = root[\\\"expected_output_file_path\\\"].asString();\\n        if(root.isMember(\\\"metadata_file_paths\\\")) {\\n            Value metadata_file_path_node = root[\\\"metadata_file_paths\\\"];\\n            if(metadata_file_path_node.isArray()) {\\n                for(int i = 0; i < (int)metadata_file_path_node.size(); i++) {\\n                    string metadata_file = metadata_file_path_node[i].asString();\\n                    t_obj.metadata_file_paths.push_back(metadata_file);\\n                }\\n            }\\n        }\\n        if(root.isMember(\\\"submission_code_path\\\"))\\n            t_obj.submission_code_path = root[\\\"submission_code_path\\\"].asString();\\n        if(root.isMember(\\\"testcase_result\\\"))\\n            t_obj.testcase_result = root[\\\"testcase_result\\\"].asBool();\\n        if(root.isMember(\\\"testcase_signal\\\"))\\n            t_obj.testcase_signal = root[\\\"testcase_signal\\\"].asInt();\\n        if(root.isMember(\\\"testcase_time\\\"))\\n            t_obj.testcase_time = root[\\\"testcase_time\\\"].asFloat();\\n        if(root.isMember(\\\"testcase_memory\\\"))\\n            t_obj.testcase_memory = root[\\\"testcase_memory\\\"].asInt();\\n        if(root.isMember(\\\"data\\\"))\\n            t_obj.data = root[\\\"data\\\"].asString();\\n    }\\n    catch(const runtime_error& error) {\\n        return 1;\\n    }\\n\\n    return 0;\\n}\\n\\nvoid write_result_json(const ResultStruct r_obj) {\\n    Value root;\\n    root[\\\"custom_result\\\"] = (int)r_obj.result;\\n    root[\\\"custom_score\\\"] = max( ((r_obj.score > 1.0f)? 1.0f : r_obj.score), 0.0f);\\n    root[\\\"custom_message\\\"] = (r_obj.message.size() > 4096)? r_obj.message.substr(0, 4095) : r_obj.message;\\n    cout << root.toStyledString() << endl;\\n}\\n\\nint main(int argc, char** argv) {\\n    // Input parameters\\n    TestStruct t_obj;\\n    t_obj.testcase_id = 0;\\n    t_obj.testcase_signal = 0;\\n    t_obj.testcase_memory = 0;\\n    t_obj.testcase_time = 0.0f;\\n    t_obj.testcase_result = true;\\n\\n    // Out parameters\\n    ResultStruct r_obj;\\n    r_obj.result = false;\\n    r_obj.score = 0.0f;\\n    r_obj.message = \\\"Uninitialized\\\";\\n\\n    if(argc < 2) {\\n        write_result_json(r_obj);\\n        return 1;\\n    }\\n\\n    // Decode input JSON\\n    int failure = read_input_json((string)argv[1],\\n                                    t_obj);\\n    // Incase input JSON was malformed or not existent\\n    if(failure) {\\n        r_obj.message = \\\"Unable to read input json\\\";\\n        write_result_json(r_obj);\\n        return 2;\\n    }\\n\\n    // Run the custom checker evaluator\\n    run_custom_checker(t_obj, r_obj);\\n\\n    // Encode result JSON\\n    write_result_json(r_obj);\\n    return 0;\\n}\\n// End of TAIL\"}", 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 30, 
            "is_solution_unlocked": false, 
            "preview": "Construct an array of a specific length that Lena's sorting algorithm will sort in a specific number of comparisons.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.6, 
            "active": true, 
            "max_score": 30, 
            "slug": "lena-sort", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Lena Sort", 
            "level": 50, 
            "success_ratio": 0.38848920863309355, 
            "total_count": 139, 
            "created_at": "2017-01-09T12:49:56.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": "cpp"
        }, 
        {
            "onboarding": null, 
            "solved_count": 6068, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:53:37.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 22923, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 30, 
            "is_solution_unlocked": false, 
            "preview": "Reverse rows and columns of a matrix to maximize the sum of the elements in the upper-left quadrant.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.65, 
            "active": true, 
            "max_score": 30, 
            "slug": "flipping-the-matrix", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Flipping the Matrix", 
            "level": 30, 
            "success_ratio": 0.8841614454320268, 
            "total_count": 6863, 
            "created_at": "2016-07-15T07:37:06.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 1239, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2016-12-03T17:52:08.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 28615, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 35, 
            "is_solution_unlocked": false, 
            "preview": "Andy and Bob are playing a game with arrays. Can you determine the winner?", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 35, 
            "slug": "an-interesting-game-1", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Gaming Array", 
            "level": 50, 
            "success_ratio": 0.7686104218362283, 
            "total_count": 1612, 
            "created_at": "2016-11-19T07:14:11.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 7968, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:51:23.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 15305, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 40, 
            "is_solution_unlocked": false, 
            "preview": "Determine how many bribes took place to get a queue into its current state.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 40, 
            "slug": "new-year-chaos", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "New Year Chaos", 
            "level": 50, 
            "success_ratio": 0.5228689546558173, 
            "total_count": 15239, 
            "created_at": "2015-12-12T19:11:55.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 1500, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:53:03.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Medium", 
            "id": 21649, 
            "has_ended": false, 
            "is_custom": true, 
            "compile_and_test": true, 
            "checker_program": "from __future__ import division\n\n###################################\n# Code specific to this checker\n###################################\n\ndef get_one_input(cas,lines):\n    ''' Get one test case from input file '''\n    n, k, b = map(int, lines.next().split(\" \"))\n    return n, k, b\n\ndef get_output_from_input(cas,lines,(n,k,b)):\n    ''' Get one test case output from output file '''\n    return map(int, lines.next().rstrip().split(\" \"))\n\nget_exp_output_from_input = get_output_from_input\n\ndef check_test_case(cas,(n,k,b),v,ev):\n    ''' Check output against input and judge output. return True if good. '''\n\n    # check whether contradiction detected correctly\n    _assert((v == [-1]) == (ev == [-1]))\n\n    # if contradiction, checking is over\n    if v == [-1]:\n        return True\n\n    # check basic stuff\n    _assert(len(v) == b)\n    _assert(all(1 <= w <= k for w in v))\n    _assert(sum(v) == n)\n    _assert(len(v) == len(set(v)))\n\n    # passed all tests\n    return True\n\ndef check_input(input_file, output_file, exp_output_file):\n    '''\n    Checks the output 'output_file' against the input 'input_file' and returns\n    a score from 0.0 to 1.0 with 1.0 being a perfect score. 'exp_output_file'\n    is the judge output file.\n    '''\n    input_lines = iter(input_file.rstrip('\\n').split('\\n'))\n    output_lines = iter(output_file.rstrip('\\n').split('\\n'))\n    exp_output_lines = iter(exp_output_file.rstrip('\\n').split('\\n'))\n\n    # get case number\n    cases = int(input_lines.next())\n    for cas in xrange(cases):\n        # process a test case\n        inp = get_one_input(cas, input_lines)\n        outp = get_output_from_input(cas, output_lines, inp)\n        exp_outp = get_exp_output_from_input(cas, exp_output_lines, inp)\n        if not check_test_case(cas, inp, outp, exp_outp):\n            return 0\n\n    # Check extra lines at end of output file\n    try:\n        output_lines.next()\n        return 0\n    except StopIteration:\n        pass\n\n    # passed all test cases\n    return 1\n\nweights = [0,5,5,5,5,5,5,10,10,10,10,10,10,10]\n\n###################################\n# Template\n###################################\n\ndef _assert(condition):\n    # can't use \"assert X\" syntax because assertions might be turned off\n    if not condition:\n        raise Exception()\n\ndef check_inputs(inputs, outputs, signals, **data):\n    ''' Checks all input/output file pairs and yields the score of each '''\n    exp_outputs = data['expected_outputs']\n    for input_file, output_file, exp_output_file, signal in zip(inputs, outputs, exp_outputs, signals):\n        result = 0\n        if signal == 0:\n            try:\n                result = float(check_input(input_file, output_file, exp_output_file))\n            except Exception:\n                result = 0\n\n        yield result\n\n \ndef process(inputs, outputs, signals, weights, **data):\n    ''' Return the overall score and the scores of each file. '''\n    scores = list(check_inputs(inputs, outputs, signals, **data))\n    total_weight = sum(weights[index] for index in xrange(len(scores)))\n    if total_weight == 0:\n        score = float(sum(scores)) / len(scores)\n    else:\n        score = float(sum(score * weight for score, weight in zip(scores, weights))) / total_weight\n    return score, scores\n\n\ndef do_scoring(weights):\n    ''' Print the scores! '''\n    from sys import stdin\n    import json\n    stdin_lines = stdin.read().split('\\n')\n \n    # Get the run directory for the submission we need to evaluate. I know, hackish right?\n    run_directory = stdin_lines[-1]\n \n    # request.json contains the data submitted for the current.\n    with open(\"%srequest.json\" % run_directory) as f:\n        request = json.load(f)\n\n    # get signals \n    with open(\"signal00.sig\") as f:\n        signals = map(int, f.read().strip().split())\n\n    # get inputs and outputs\n    inputs = []\n    outputs = []\n    for index in xrange(len(request[\"testcase_sources\"])):\n        with open(\"%sinput%05d.in\" % (run_directory, index)) as f:\n            inputs.append(f.read())\n        with open(\"%soutput%05d.out\" % (run_directory, index)) as f:\n            outputs.append(f.read())\n\n    # Gathered all the data we could, let's process it\n    score, testcase_status = process(\n        inputs,\n        outputs,\n        signals,\n        weights,\n        expected_outputs=request[\"expected_outputs\"],\n        source=request[\"source\"],\n        testcases=request[\"testcase_sources\"],\n        lang=request[\"lang\"],\n    )\n \n    # Write the resulting scores\n    print score\n    print \" \".join(str(i) for i in testcase_status)\n\n# this starts things up\nif __name__ == \"__main__\":\n    do_scoring(weights)\n", 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 50, 
            "is_solution_unlocked": false, 
            "preview": "I don't have the stomach for this...", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.7, 
            "active": true, 
            "max_score": 50, 
            "slug": "bonetrousle", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Bonetrousle", 
            "level": 50, 
            "success_ratio": 0.46296296296296297, 
            "total_count": 3240, 
            "created_at": "2016-05-20T17:10:32.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": "python"
        }, 
        {
            "onboarding": null, 
            "solved_count": 532, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:50:06.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 9000, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Use the idea of KMP failure function.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 60, 
            "slug": "kmp-problem", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Yet Another KMP Problem", 
            "level": 50, 
            "success_ratio": 0.5611814345991561, 
            "total_count": 948, 
            "created_at": "2015-06-28T19:31:24.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 395, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:51:11.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 14803, 
            "has_ended": false, 
            "is_custom": true, 
            "compile_and_test": true, 
            "checker_program": "from __future__ import division\nimport json\nfrom sys import stdin\n\ndef get_n(s):\n    return int(s.split(\"\\n\")[0])\n    \ndef get_s(output):\n    lines = output.strip().split(\"\\n\")    \n    bad = (False, 0, 0)\n    try:\n        m = int(lines[0])\n    except Exception:\n        return bad\n    if len(lines) != m + 1:\n        return bad\n    sx = set()\n    sy = set()\n    sz = set()\n    su = set()\n    lines = lines[1:]    \n    for line in lines:\n        try:\n            a, b, c = line.strip().split()\n            a = int(a)\n            b = int(b)\n            c = int(c)\n        except Exception:\n            return bad\n        if a in sx:\n            return bad\n        if b in sy:\n            return bad\n        if c in sz:\n            return bad\n        sx.add(a)\n        sy.add(b)\n        sz.add(c)\n        su.add(a + b + c)\n    if len(su) != 1:\n        return bad\n    return True, m, list(su)[0]\n        \n       \n        \n\ndef check_inputs (inputs, outputs, user_outputs):\n    #inputs is a \"python list\" of all input files. Inputs contains the contents of each of these files.\n\n    is_code_works = True\n    '''\n    This is the boolean flag to check if the code works or not.\n    If you want to give a complete 0 score and give a wrong answer, set this flag to False\n    '''\n\n    scores = [ 0 for i in range( len( inputs ) ) ]\n    '''\n    This is an array of scores for each test case\n    Each element in the array should be between 0 and 1\n    We initially fill this array with 0\n    '''\n\n    testcase_status = [ 0 for i in range( len( inputs ) ) ]\n    '''\n    This is an array of status for each test case.\n    Each element in the array can be either 0 or 1\n    We initially fill this array with 0\n    '''\n\n    loop_counter = 0\n    for input_tc, output_tc, useroutput_tc in zip(inputs, outputs, user_outputs):\n        '''\n        input_tc, output_tc and useroutput_tc is the content of 1 complete file.\n        Remember to split on \"\\n\". Default split is a common mistake. Remember to trim the lines.\n        Custom checker should NEVER throw an error\n        Run it in try: except: blocks and verify input to avoid infinite time errors\n\n        Your code will read input_tc, output_tc and useroutput_tc\n        Your code will update is_code_works, scores[loop_counter], testcase_status[loop_counter]\n        '''\n        \n\n        N = get_n(input_tc)        \n        M = (N + N) // 3 + 1\n        oko, mo, so = get_s(output_tc)\n        okc, mc, sc = get_s(useroutput_tc)\n        \n        if oko == okc and mo == mc and so == sc and mc == M:\n            testcase_status[loop_counter] = 1\n            scores[loop_counter] = 1\n        \n        #YOUR CUSTOM CODE STARTS HERE\n\n\n        #YOUR CUSTOM CODE ENDS HERE\n\n        loop_counter += 1\n    return is_code_works, scores, testcase_status\n\ndef process(data):\n    score = 0\n    testcase_input  = data[\"inputs\"]\n    testcase_output = data[\"expected_outputs\"]\n    user_output     = data[\"outputs\"]\n    is_code_works, scores, testcase_statuses = check_inputs(testcase_input, testcase_output, user_output)\n    if is_code_works:\n        for current_testcase_score in scores:\n            score += current_testcase_score\n    return score / (len(scores)), testcase_statuses\n\nif __name__ ==  '__main__':\n    stdin = stdin.read().split('\\n')\n\n    # Get the run directory for the submission we need to evaluate.\n    run_directory = stdin[-1]\n\n    # request.json contains the data submitted for the current.\n    request = json.load(open(run_directory + \"request.json\"))\n\n    data = {\n        # The submitted source code\n        \"source\": request[\"source\"],\n        # The list of test cases\n        \"testcases\": request[\"testcase_sources\"],\n        # The submitted language key (Eg: 5 for python)\n        \"lang\": request[\"lang\"],\n        # I'll tell you how to fill this next\n        \"expected_outputs\": request[\"expected_outputs\"],\n        \"inputs\": [],\n        \"outputs\": []\n    }\n\n    for index in range(len(request[\"testcase_sources\"])):\n        #Let's read the input00000.in files.\n        inputs = open(run_directory + \"input%05d.in\" %(index)).read()\n        data[\"inputs\"].append(inputs)\n\n        #Let's read the output00000.out files.\n        output = open(run_directory + \"output%05d.out\" %(index)).read()\n        data[\"outputs\"].append(output)\n\n    # Gathered all the data we could, lets process it\n    score, testcase_status = process(data)\n\n    #Let me explain what you should even print as output of customer checker.\n    #Line 1 should be the total score for the submission\n    #Line 2 should be a list of space separated integers (0/1), which denotes testcase status of each testcase\n    #Line 3 should be a list of space separated floats, which denotes testcase score of each testcase.\n    print score\n    print \" \".join(str(i) for i in testcase_status)\n    print \" \".join(\"2\" for i in testcase_status)", 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Given $n$, construct set $S$ and find the beautiful triples.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 60, 
            "slug": "beautiful-3-set", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Beautiful 3 Set", 
            "level": 60, 
            "success_ratio": 0.4782082324455206, 
            "total_count": 826, 
            "created_at": "2015-11-26T23:28:44.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": "python"
        }, 
        {
            "onboarding": null, 
            "solved_count": 264, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:51:39.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Hard", 
            "id": 15896, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 60, 
            "is_solution_unlocked": false, 
            "preview": "Given a shuffled array of some segment tree that solves an RMQ task, determine if you can restore the original segment tree.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.5, 
            "active": true, 
            "max_score": 60, 
            "slug": "inverse-rmq", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Inverse RMQ", 
            "level": 50, 
            "success_ratio": 0.5387755102040817, 
            "total_count": 490, 
            "created_at": "2016-01-09T17:28:53.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 11, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-03-02T12:08:56.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Expert", 
            "id": 29356, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 70, 
            "is_solution_unlocked": false, 
            "preview": "Help little Lima to find the biggest subarray sum.", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.1, 
            "active": true, 
            "max_score": 70, 
            "slug": "two-subarrays", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Two Subarrays", 
            "level": 50, 
            "success_ratio": 0.21568627450980393, 
            "total_count": 51, 
            "created_at": "2016-12-07T10:49:23.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }, 
        {
            "onboarding": null, 
            "solved_count": 200, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2017-07-11T15:52:06.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 18055, 
            "has_ended": false, 
            "is_custom": true, 
            "compile_and_test": true, 
            "checker_program": "from __future__ import division\nimport json\nfrom sys import stdin\n\ndef getn(outps,Q):\n    A = []\n    if len(outps)>0:\n        A = outps[0].strip().split()\n    if len(A)!=2:\n        return 0\n        \n    def isint(value):\n        try:\n            int(value)\n            return True\n        except ValueError:\n            return False\n\n    if not isint(A[0]) or not isint(A[1]):\n        return 0\n\n    N,M = map(int,A)\n\n    if N<0 or 100<N or M<0 or 100<M:\n        return 0\n\n    if len(outps)!=M+1:\n        return 0\n\n    D = [[100]*(N+2) for i in xrange(N+2)]\n\n    for i in xrange(1,M+1):\n        B = outps[i].strip().split()\n        if len(B)!=2:\n            return 0\n        if not isint(B[0]) or not isint(B[1]):\n            return 0\n        x,y = map(int,B)\n        if x<1 or N<x or y<1 or N<y:\n            return 0\n        D[x][y] = 1\n        D[y][x] = 1\n\n    for i in xrange(1,N+1):\n        D[i][i] = 0\n\n    for k in xrange(1,N+1):\n        for i in xrange(1,N+1):\n            for j in xrange(1,N+1):\n                if D[i][j]>D[i][k]+D[k][j]:\n                    D[i][j]=D[i][k]+D[k][j]\n\n    num = 0\n    for i in xrange(1,N+1):\n        for j in xrange(i+1,N+1):\n            for k in xrange(j+1,N+1):\n                num += (D[i][j] == Q and D[i][k] == Q and D[j][k] == Q)\n    \n    return num\n\ndef check_inputs (inputs, outputs):\n    lis = []\n    for inps, outps in zip(inputs, outputs):\n        ok = 0\n        score = 0\n        \n        inps = inps.strip().split(\"\\n\")\n        outps = outps.strip().split(\"\\n\")\n       \n        P, Q = [int(x) for x in inps[0].strip().split()]\n\n        if getn(outps,Q)==P:\n            score = 1\n        \n        lis.append(score)\n    return True, lis\n\ndef process(data):\n    # Whatever you do, I am not giving any marks!\n    score = 0\n \n    a,b = check_inputs(data[\"inputs\"], data[\"outputs\"])\n    score = 0\n    if len(b)==1:\n        score = b.count(1)/len(b)\n    else:\n        score = b[1::].count(1)/len(b[1::])\n    return score, b\n \nif __name__ ==  '__main__':\n    stdin = stdin.read().split('\\n')\n \n    # Get the run directory for the submission we need to evaluate. I know,\n    # hackish right?\n    run_directory = stdin[-1]\n \n    # request.json contains the data submitted for the current.\n    request = json.load(open(run_directory + \"request.json\"))\n \n    data = {\n        # The submitted source code\n        \"source\": request[\"source\"],\n        # The list of test cases\n        \"testcases\": request[\"testcase_sources\"],\n        # The submitted language key (Eg: 5 for python)\n        \"lang\": request[\"lang\"],\n        # I'll tell you how to fill this next\n        \"expected_outputs\": request[\"expected_outputs\"],\n        \"outputs\": [],\n        \"inputs\": [],\n    }\n \n    for index in range(len(request[\"testcase_sources\"])):\n        output = open(run_directory + \"output%05d.out\" %(index)).read()\n        data[\"outputs\"].append(output)\n \n    for index in range(len(request[\"testcase_sources\"])):\n        inputs = open(run_directory + \"input%05d.in\" %(index)).read()\n        data[\"inputs\"].append(inputs)\n    # Gathered all the data we could, lets process it\n    score, testcase_status = process(data)\n \n    print score\n    print \" \".join(str(i) for i in testcase_status)\n", 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": true, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Find the number of lovely triplets and help Daniel draw a special graph!", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 1.0, 
            "difficulty": 0.3, 
            "active": true, 
            "max_score": 80, 
            "slug": "lovely-triplets", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Lovely Triplets", 
            "level": 50, 
            "success_ratio": 0.6410256410256411, 
            "total_count": 312, 
            "created_at": "2016-02-27T11:03:29.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": "python"
        }, 
        {
            "onboarding": null, 
            "solved_count": 194, 
            "preview_format": null, 
            "can_solve": true, 
            "public_test_cases": true, 
            "topics": [], 
            "time_left": null, 
            "updated_at": "2016-12-16T00:14:13.000Z", 
            "has_started": true, 
            "epoch_starttime": null, 
            "difficulty_name": "Advanced", 
            "id": 22032, 
            "has_ended": false, 
            "is_custom": false, 
            "compile_and_test": true, 
            "checker_program": null, 
            "submit_disabled": false, 
            "expert_solution_status": false, 
            "company_id": null, 
            "custom": false, 
            "can_be_viewed": true, 
            "deleted": false, 
            "factor": 80, 
            "is_solution_unlocked": false, 
            "preview": "Help Professor GukiZ construct an array!", 
            "is_editorial_available": true, 
            "status": null, 
            "category": "ai", 
            "public_solutions": true, 
            "color": null, 
            "track": {
                "name": "Constructive Algorithms", 
                "taxonomy": 1, 
                "track_slug": "algorithms", 
                "track_id": 3, 
                "track_name": "Algorithms", 
                "id": 151, 
                "rewards_system_enabled": true, 
                "slug": "constructive-algorithms"
            }, 
            "dynamic": false, 
            "company": null, 
            "is_text": false, 
            "solved_score": 0.5, 
            "difficulty": 0.3, 
            "active": true, 
            "max_score": 80, 
            "slug": "array-construction", 
            "contest_slug": "master", 
            "user_score": 0, 
            "kind": "code", 
            "player_count": 2, 
            "name": "Array Construction", 
            "level": 65, 
            "success_ratio": 0.5434173669467787, 
            "total_count": 357, 
            "created_at": "2016-06-06T18:03:00.000Z", 
            "epoch_endtime": null, 
            "judgebot": null, 
            "countdown_time": 0, 
            "custom_tabs": null, 
            "judgebot_language": null, 
            "custom_case": true, 
            "requirements_description": null, 
            "is_skip_band_challenge": false, 
            "custom_checker_language": null
        }
    ], 
    "tutorial_signed_up": true, 
    "current_track": {
        "name": "Algorithms", 
        "id": 3, 
        "priority": 14, 
        "descriptions": "The true test of problem solving: when one realizes that time and memory aren't infinite.\n", 
        "rewards_system_enabled": true, 
        "slug": "algorithms"
    }, 
    "total": 11
}